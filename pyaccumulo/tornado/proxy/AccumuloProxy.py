#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:tornado
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None

from tornado import gen
from tornado import stack_context

class Iface(object):
  def login(self, principal, loginProperties, callback):
    """
    Parameters:
     - principal
     - loginProperties
    """
    pass

  def addConstraint(self, login, tableName, constraintClassName, callback):
    """
    Parameters:
     - login
     - tableName
     - constraintClassName
    """
    pass

  def addSplits(self, login, tableName, splits, callback):
    """
    Parameters:
     - login
     - tableName
     - splits
    """
    pass

  def attachIterator(self, login, tableName, setting, scopes, callback):
    """
    Parameters:
     - login
     - tableName
     - setting
     - scopes
    """
    pass

  def checkIteratorConflicts(self, login, tableName, setting, scopes, callback):
    """
    Parameters:
     - login
     - tableName
     - setting
     - scopes
    """
    pass

  def clearLocatorCache(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    pass

  def cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude, callback):
    """
    Parameters:
     - login
     - tableName
     - newTableName
     - flush
     - propertiesToSet
     - propertiesToExclude
    """
    pass

  def compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait, callback):
    """
    Parameters:
     - login
     - tableName
     - startRow
     - endRow
     - iterators
     - flush
     - wait
    """
    pass

  def cancelCompaction(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    pass

  def createTable(self, login, tableName, versioningIter, type, callback):
    """
    Parameters:
     - login
     - tableName
     - versioningIter
     - type
    """
    pass

  def deleteTable(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    pass

  def deleteRows(self, login, tableName, startRow, endRow, callback):
    """
    Parameters:
     - login
     - tableName
     - startRow
     - endRow
    """
    pass

  def exportTable(self, login, tableName, exportDir, callback):
    """
    Parameters:
     - login
     - tableName
     - exportDir
    """
    pass

  def flushTable(self, login, tableName, startRow, endRow, wait, callback):
    """
    Parameters:
     - login
     - tableName
     - startRow
     - endRow
     - wait
    """
    pass

  def getDiskUsage(self, login, tables, callback):
    """
    Parameters:
     - login
     - tables
    """
    pass

  def getLocalityGroups(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    pass

  def getIteratorSetting(self, login, tableName, iteratorName, scope, callback):
    """
    Parameters:
     - login
     - tableName
     - iteratorName
     - scope
    """
    pass

  def getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive, callback):
    """
    Parameters:
     - login
     - tableName
     - auths
     - startRow
     - startInclusive
     - endRow
     - endInclusive
    """
    pass

  def getTableProperties(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    pass

  def importDirectory(self, login, tableName, importDir, failureDir, setTime, callback):
    """
    Parameters:
     - login
     - tableName
     - importDir
     - failureDir
     - setTime
    """
    pass

  def importTable(self, login, tableName, importDir, callback):
    """
    Parameters:
     - login
     - tableName
     - importDir
    """
    pass

  def listSplits(self, login, tableName, maxSplits, callback):
    """
    Parameters:
     - login
     - tableName
     - maxSplits
    """
    pass

  def listTables(self, login, callback):
    """
    Parameters:
     - login
    """
    pass

  def listIterators(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    pass

  def listConstraints(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    pass

  def mergeTablets(self, login, tableName, startRow, endRow, callback):
    """
    Parameters:
     - login
     - tableName
     - startRow
     - endRow
    """
    pass

  def offlineTable(self, login, tableName, wait, callback):
    """
    Parameters:
     - login
     - tableName
     - wait
    """
    pass

  def onlineTable(self, login, tableName, wait, callback):
    """
    Parameters:
     - login
     - tableName
     - wait
    """
    pass

  def removeConstraint(self, login, tableName, constraint, callback):
    """
    Parameters:
     - login
     - tableName
     - constraint
    """
    pass

  def removeIterator(self, login, tableName, iterName, scopes, callback):
    """
    Parameters:
     - login
     - tableName
     - iterName
     - scopes
    """
    pass

  def removeTableProperty(self, login, tableName, property, callback):
    """
    Parameters:
     - login
     - tableName
     - property
    """
    pass

  def renameTable(self, login, oldTableName, newTableName, callback):
    """
    Parameters:
     - login
     - oldTableName
     - newTableName
    """
    pass

  def setLocalityGroups(self, login, tableName, groups, callback):
    """
    Parameters:
     - login
     - tableName
     - groups
    """
    pass

  def setTableProperty(self, login, tableName, property, value, callback):
    """
    Parameters:
     - login
     - tableName
     - property
     - value
    """
    pass

  def splitRangeByTablets(self, login, tableName, range, maxSplits, callback):
    """
    Parameters:
     - login
     - tableName
     - range
     - maxSplits
    """
    pass

  def tableExists(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    pass

  def tableIdMap(self, login, callback):
    """
    Parameters:
     - login
    """
    pass

  def testTableClassLoad(self, login, tableName, className, asTypeName, callback):
    """
    Parameters:
     - login
     - tableName
     - className
     - asTypeName
    """
    pass

  def pingTabletServer(self, login, tserver, callback):
    """
    Parameters:
     - login
     - tserver
    """
    pass

  def getActiveScans(self, login, tserver, callback):
    """
    Parameters:
     - login
     - tserver
    """
    pass

  def getActiveCompactions(self, login, tserver, callback):
    """
    Parameters:
     - login
     - tserver
    """
    pass

  def getSiteConfiguration(self, login, callback):
    """
    Parameters:
     - login
    """
    pass

  def getSystemConfiguration(self, login, callback):
    """
    Parameters:
     - login
    """
    pass

  def getTabletServers(self, login, callback):
    """
    Parameters:
     - login
    """
    pass

  def removeProperty(self, login, property, callback):
    """
    Parameters:
     - login
     - property
    """
    pass

  def setProperty(self, login, property, value, callback):
    """
    Parameters:
     - login
     - property
     - value
    """
    pass

  def testClassLoad(self, login, className, asTypeName, callback):
    """
    Parameters:
     - login
     - className
     - asTypeName
    """
    pass

  def authenticateUser(self, login, user, properties, callback):
    """
    Parameters:
     - login
     - user
     - properties
    """
    pass

  def changeUserAuthorizations(self, login, user, authorizations, callback):
    """
    Parameters:
     - login
     - user
     - authorizations
    """
    pass

  def changeLocalUserPassword(self, login, user, password, callback):
    """
    Parameters:
     - login
     - user
     - password
    """
    pass

  def createLocalUser(self, login, user, password, callback):
    """
    Parameters:
     - login
     - user
     - password
    """
    pass

  def dropLocalUser(self, login, user, callback):
    """
    Parameters:
     - login
     - user
    """
    pass

  def getUserAuthorizations(self, login, user, callback):
    """
    Parameters:
     - login
     - user
    """
    pass

  def grantSystemPermission(self, login, user, perm, callback):
    """
    Parameters:
     - login
     - user
     - perm
    """
    pass

  def grantTablePermission(self, login, user, table, perm, callback):
    """
    Parameters:
     - login
     - user
     - table
     - perm
    """
    pass

  def hasSystemPermission(self, login, user, perm, callback):
    """
    Parameters:
     - login
     - user
     - perm
    """
    pass

  def hasTablePermission(self, login, user, table, perm, callback):
    """
    Parameters:
     - login
     - user
     - table
     - perm
    """
    pass

  def listLocalUsers(self, login, callback):
    """
    Parameters:
     - login
    """
    pass

  def revokeSystemPermission(self, login, user, perm, callback):
    """
    Parameters:
     - login
     - user
     - perm
    """
    pass

  def revokeTablePermission(self, login, user, table, perm, callback):
    """
    Parameters:
     - login
     - user
     - table
     - perm
    """
    pass

  def createBatchScanner(self, login, tableName, options, callback):
    """
    Parameters:
     - login
     - tableName
     - options
    """
    pass

  def createScanner(self, login, tableName, options, callback):
    """
    Parameters:
     - login
     - tableName
     - options
    """
    pass

  def hasNext(self, scanner, callback):
    """
    Parameters:
     - scanner
    """
    pass

  def nextEntry(self, scanner, callback):
    """
    Parameters:
     - scanner
    """
    pass

  def nextK(self, scanner, k, callback):
    """
    Parameters:
     - scanner
     - k
    """
    pass

  def closeScanner(self, scanner, callback):
    """
    Parameters:
     - scanner
    """
    pass

  def updateAndFlush(self, login, tableName, cells, callback):
    """
    Parameters:
     - login
     - tableName
     - cells
    """
    pass

  def createWriter(self, login, tableName, opts, callback):
    """
    Parameters:
     - login
     - tableName
     - opts
    """
    pass

  def update(self, writer, cells, callback=None):
    """
    Parameters:
     - writer
     - cells
    """
    pass

  def flush(self, writer, callback):
    """
    Parameters:
     - writer
    """
    pass

  def closeWriter(self, writer, callback):
    """
    Parameters:
     - writer
    """
    pass

  def updateRowConditionally(self, login, tableName, row, updates, callback):
    """
    Parameters:
     - login
     - tableName
     - row
     - updates
    """
    pass

  def createConditionalWriter(self, login, tableName, options, callback):
    """
    Parameters:
     - login
     - tableName
     - options
    """
    pass

  def updateRowsConditionally(self, conditionalWriter, updates, callback):
    """
    Parameters:
     - conditionalWriter
     - updates
    """
    pass

  def closeConditionalWriter(self, conditionalWriter, callback):
    """
    Parameters:
     - conditionalWriter
    """
    pass

  def getRowRange(self, row, callback):
    """
    Parameters:
     - row
    """
    pass

  def getFollowing(self, key, part, callback):
    """
    Parameters:
     - key
     - part
    """
    pass


class Client(Iface):
  def __init__(self, transport, iprot_factory, oprot_factory=None):
    self._transport = transport
    self._iprot_factory = iprot_factory
    self._oprot_factory = (oprot_factory if oprot_factory is not None
                           else iprot_factory)
    self._seqid = 0
    self._reqs = {}

  @gen.engine
  def recv_dispatch(self):
    """read a response from the wire. schedule exactly one per send that
    expects a response, but it doesn't matter which callee gets which
    response; they're dispatched here properly"""

    # wait for a frame header
    frame = yield gen.Task(self._transport.readFrame)
    tr = TTransport.TMemoryBuffer(frame)
    iprot = self._iprot_factory.getProtocol(tr)
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    method = getattr(self, 'recv_' + fname)
    method(iprot, mtype, rseqid)

  def login(self, principal, loginProperties, callback):
    """
    Parameters:
     - principal
     - loginProperties
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_login(principal, loginProperties)
    self.recv_dispatch()

  def send_login(self, principal, loginProperties):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('login', TMessageType.CALL, self._seqid)
    args = login_args()
    args.principal = principal
    args.loginProperties = loginProperties
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_login(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = login_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result"))
    return

  def addConstraint(self, login, tableName, constraintClassName, callback):
    """
    Parameters:
     - login
     - tableName
     - constraintClassName
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_addConstraint(login, tableName, constraintClassName)
    self.recv_dispatch()

  def send_addConstraint(self, login, tableName, constraintClassName):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('addConstraint', TMessageType.CALL, self._seqid)
    args = addConstraint_args()
    args.login = login
    args.tableName = tableName
    args.constraintClassName = constraintClassName
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_addConstraint(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = addConstraint_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "addConstraint failed: unknown result"))
    return

  def addSplits(self, login, tableName, splits, callback):
    """
    Parameters:
     - login
     - tableName
     - splits
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_addSplits(login, tableName, splits)
    self.recv_dispatch()

  def send_addSplits(self, login, tableName, splits):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('addSplits', TMessageType.CALL, self._seqid)
    args = addSplits_args()
    args.login = login
    args.tableName = tableName
    args.splits = splits
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_addSplits(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = addSplits_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def attachIterator(self, login, tableName, setting, scopes, callback):
    """
    Parameters:
     - login
     - tableName
     - setting
     - scopes
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_attachIterator(login, tableName, setting, scopes)
    self.recv_dispatch()

  def send_attachIterator(self, login, tableName, setting, scopes):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('attachIterator', TMessageType.CALL, self._seqid)
    args = attachIterator_args()
    args.login = login
    args.tableName = tableName
    args.setting = setting
    args.scopes = scopes
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_attachIterator(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = attachIterator_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def checkIteratorConflicts(self, login, tableName, setting, scopes, callback):
    """
    Parameters:
     - login
     - tableName
     - setting
     - scopes
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_checkIteratorConflicts(login, tableName, setting, scopes)
    self.recv_dispatch()

  def send_checkIteratorConflicts(self, login, tableName, setting, scopes):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('checkIteratorConflicts', TMessageType.CALL, self._seqid)
    args = checkIteratorConflicts_args()
    args.login = login
    args.tableName = tableName
    args.setting = setting
    args.scopes = scopes
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_checkIteratorConflicts(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = checkIteratorConflicts_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def clearLocatorCache(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_clearLocatorCache(login, tableName)
    self.recv_dispatch()

  def send_clearLocatorCache(self, login, tableName):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('clearLocatorCache', TMessageType.CALL, self._seqid)
    args = clearLocatorCache_args()
    args.login = login
    args.tableName = tableName
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_clearLocatorCache(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = clearLocatorCache_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    callback(None)
    return

  def cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude, callback):
    """
    Parameters:
     - login
     - tableName
     - newTableName
     - flush
     - propertiesToSet
     - propertiesToExclude
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_cloneTable(login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude)
    self.recv_dispatch()

  def send_cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('cloneTable', TMessageType.CALL, self._seqid)
    args = cloneTable_args()
    args.login = login
    args.tableName = tableName
    args.newTableName = newTableName
    args.flush = flush
    args.propertiesToSet = propertiesToSet
    args.propertiesToExclude = propertiesToExclude
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_cloneTable(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = cloneTable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    if result.ouch4 is not None:
      callback(result.ouch4)
      return
    callback(None)
    return

  def compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait, callback):
    """
    Parameters:
     - login
     - tableName
     - startRow
     - endRow
     - iterators
     - flush
     - wait
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_compactTable(login, tableName, startRow, endRow, iterators, flush, wait)
    self.recv_dispatch()

  def send_compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('compactTable', TMessageType.CALL, self._seqid)
    args = compactTable_args()
    args.login = login
    args.tableName = tableName
    args.startRow = startRow
    args.endRow = endRow
    args.iterators = iterators
    args.flush = flush
    args.wait = wait
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_compactTable(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = compactTable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def cancelCompaction(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_cancelCompaction(login, tableName)
    self.recv_dispatch()

  def send_cancelCompaction(self, login, tableName):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('cancelCompaction', TMessageType.CALL, self._seqid)
    args = cancelCompaction_args()
    args.login = login
    args.tableName = tableName
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_cancelCompaction(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = cancelCompaction_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def createTable(self, login, tableName, versioningIter, type, callback):
    """
    Parameters:
     - login
     - tableName
     - versioningIter
     - type
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_createTable(login, tableName, versioningIter, type)
    self.recv_dispatch()

  def send_createTable(self, login, tableName, versioningIter, type):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('createTable', TMessageType.CALL, self._seqid)
    args = createTable_args()
    args.login = login
    args.tableName = tableName
    args.versioningIter = versioningIter
    args.type = type
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_createTable(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = createTable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def deleteTable(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_deleteTable(login, tableName)
    self.recv_dispatch()

  def send_deleteTable(self, login, tableName):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('deleteTable', TMessageType.CALL, self._seqid)
    args = deleteTable_args()
    args.login = login
    args.tableName = tableName
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_deleteTable(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = deleteTable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def deleteRows(self, login, tableName, startRow, endRow, callback):
    """
    Parameters:
     - login
     - tableName
     - startRow
     - endRow
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_deleteRows(login, tableName, startRow, endRow)
    self.recv_dispatch()

  def send_deleteRows(self, login, tableName, startRow, endRow):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('deleteRows', TMessageType.CALL, self._seqid)
    args = deleteRows_args()
    args.login = login
    args.tableName = tableName
    args.startRow = startRow
    args.endRow = endRow
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_deleteRows(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = deleteRows_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def exportTable(self, login, tableName, exportDir, callback):
    """
    Parameters:
     - login
     - tableName
     - exportDir
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_exportTable(login, tableName, exportDir)
    self.recv_dispatch()

  def send_exportTable(self, login, tableName, exportDir):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('exportTable', TMessageType.CALL, self._seqid)
    args = exportTable_args()
    args.login = login
    args.tableName = tableName
    args.exportDir = exportDir
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_exportTable(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = exportTable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def flushTable(self, login, tableName, startRow, endRow, wait, callback):
    """
    Parameters:
     - login
     - tableName
     - startRow
     - endRow
     - wait
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_flushTable(login, tableName, startRow, endRow, wait)
    self.recv_dispatch()

  def send_flushTable(self, login, tableName, startRow, endRow, wait):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('flushTable', TMessageType.CALL, self._seqid)
    args = flushTable_args()
    args.login = login
    args.tableName = tableName
    args.startRow = startRow
    args.endRow = endRow
    args.wait = wait
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_flushTable(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = flushTable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def getDiskUsage(self, login, tables, callback):
    """
    Parameters:
     - login
     - tables
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_getDiskUsage(login, tables)
    self.recv_dispatch()

  def send_getDiskUsage(self, login, tables):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getDiskUsage', TMessageType.CALL, self._seqid)
    args = getDiskUsage_args()
    args.login = login
    args.tables = tables
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getDiskUsage(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = getDiskUsage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "getDiskUsage failed: unknown result"))
    return

  def getLocalityGroups(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_getLocalityGroups(login, tableName)
    self.recv_dispatch()

  def send_getLocalityGroups(self, login, tableName):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getLocalityGroups', TMessageType.CALL, self._seqid)
    args = getLocalityGroups_args()
    args.login = login
    args.tableName = tableName
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getLocalityGroups(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = getLocalityGroups_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "getLocalityGroups failed: unknown result"))
    return

  def getIteratorSetting(self, login, tableName, iteratorName, scope, callback):
    """
    Parameters:
     - login
     - tableName
     - iteratorName
     - scope
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_getIteratorSetting(login, tableName, iteratorName, scope)
    self.recv_dispatch()

  def send_getIteratorSetting(self, login, tableName, iteratorName, scope):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getIteratorSetting', TMessageType.CALL, self._seqid)
    args = getIteratorSetting_args()
    args.login = login
    args.tableName = tableName
    args.iteratorName = iteratorName
    args.scope = scope
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getIteratorSetting(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = getIteratorSetting_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "getIteratorSetting failed: unknown result"))
    return

  def getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive, callback):
    """
    Parameters:
     - login
     - tableName
     - auths
     - startRow
     - startInclusive
     - endRow
     - endInclusive
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_getMaxRow(login, tableName, auths, startRow, startInclusive, endRow, endInclusive)
    self.recv_dispatch()

  def send_getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getMaxRow', TMessageType.CALL, self._seqid)
    args = getMaxRow_args()
    args.login = login
    args.tableName = tableName
    args.auths = auths
    args.startRow = startRow
    args.startInclusive = startInclusive
    args.endRow = endRow
    args.endInclusive = endInclusive
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getMaxRow(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = getMaxRow_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "getMaxRow failed: unknown result"))
    return

  def getTableProperties(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_getTableProperties(login, tableName)
    self.recv_dispatch()

  def send_getTableProperties(self, login, tableName):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getTableProperties', TMessageType.CALL, self._seqid)
    args = getTableProperties_args()
    args.login = login
    args.tableName = tableName
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getTableProperties(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = getTableProperties_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "getTableProperties failed: unknown result"))
    return

  def importDirectory(self, login, tableName, importDir, failureDir, setTime, callback):
    """
    Parameters:
     - login
     - tableName
     - importDir
     - failureDir
     - setTime
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_importDirectory(login, tableName, importDir, failureDir, setTime)
    self.recv_dispatch()

  def send_importDirectory(self, login, tableName, importDir, failureDir, setTime):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('importDirectory', TMessageType.CALL, self._seqid)
    args = importDirectory_args()
    args.login = login
    args.tableName = tableName
    args.importDir = importDir
    args.failureDir = failureDir
    args.setTime = setTime
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_importDirectory(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = importDirectory_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    if result.ouch4 is not None:
      callback(result.ouch4)
      return
    callback(None)
    return

  def importTable(self, login, tableName, importDir, callback):
    """
    Parameters:
     - login
     - tableName
     - importDir
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_importTable(login, tableName, importDir)
    self.recv_dispatch()

  def send_importTable(self, login, tableName, importDir):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('importTable', TMessageType.CALL, self._seqid)
    args = importTable_args()
    args.login = login
    args.tableName = tableName
    args.importDir = importDir
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_importTable(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = importTable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def listSplits(self, login, tableName, maxSplits, callback):
    """
    Parameters:
     - login
     - tableName
     - maxSplits
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_listSplits(login, tableName, maxSplits)
    self.recv_dispatch()

  def send_listSplits(self, login, tableName, maxSplits):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('listSplits', TMessageType.CALL, self._seqid)
    args = listSplits_args()
    args.login = login
    args.tableName = tableName
    args.maxSplits = maxSplits
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_listSplits(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = listSplits_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "listSplits failed: unknown result"))
    return

  def listTables(self, login, callback):
    """
    Parameters:
     - login
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_listTables(login)
    self.recv_dispatch()

  def send_listTables(self, login):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('listTables', TMessageType.CALL, self._seqid)
    args = listTables_args()
    args.login = login
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_listTables(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = listTables_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "listTables failed: unknown result"))
    return

  def listIterators(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_listIterators(login, tableName)
    self.recv_dispatch()

  def send_listIterators(self, login, tableName):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('listIterators', TMessageType.CALL, self._seqid)
    args = listIterators_args()
    args.login = login
    args.tableName = tableName
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_listIterators(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = listIterators_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "listIterators failed: unknown result"))
    return

  def listConstraints(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_listConstraints(login, tableName)
    self.recv_dispatch()

  def send_listConstraints(self, login, tableName):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('listConstraints', TMessageType.CALL, self._seqid)
    args = listConstraints_args()
    args.login = login
    args.tableName = tableName
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_listConstraints(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = listConstraints_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "listConstraints failed: unknown result"))
    return

  def mergeTablets(self, login, tableName, startRow, endRow, callback):
    """
    Parameters:
     - login
     - tableName
     - startRow
     - endRow
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_mergeTablets(login, tableName, startRow, endRow)
    self.recv_dispatch()

  def send_mergeTablets(self, login, tableName, startRow, endRow):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('mergeTablets', TMessageType.CALL, self._seqid)
    args = mergeTablets_args()
    args.login = login
    args.tableName = tableName
    args.startRow = startRow
    args.endRow = endRow
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_mergeTablets(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = mergeTablets_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def offlineTable(self, login, tableName, wait, callback):
    """
    Parameters:
     - login
     - tableName
     - wait
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_offlineTable(login, tableName, wait)
    self.recv_dispatch()

  def send_offlineTable(self, login, tableName, wait):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('offlineTable', TMessageType.CALL, self._seqid)
    args = offlineTable_args()
    args.login = login
    args.tableName = tableName
    args.wait = wait
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_offlineTable(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = offlineTable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def onlineTable(self, login, tableName, wait, callback):
    """
    Parameters:
     - login
     - tableName
     - wait
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_onlineTable(login, tableName, wait)
    self.recv_dispatch()

  def send_onlineTable(self, login, tableName, wait):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('onlineTable', TMessageType.CALL, self._seqid)
    args = onlineTable_args()
    args.login = login
    args.tableName = tableName
    args.wait = wait
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_onlineTable(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = onlineTable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def removeConstraint(self, login, tableName, constraint, callback):
    """
    Parameters:
     - login
     - tableName
     - constraint
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_removeConstraint(login, tableName, constraint)
    self.recv_dispatch()

  def send_removeConstraint(self, login, tableName, constraint):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('removeConstraint', TMessageType.CALL, self._seqid)
    args = removeConstraint_args()
    args.login = login
    args.tableName = tableName
    args.constraint = constraint
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_removeConstraint(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = removeConstraint_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def removeIterator(self, login, tableName, iterName, scopes, callback):
    """
    Parameters:
     - login
     - tableName
     - iterName
     - scopes
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_removeIterator(login, tableName, iterName, scopes)
    self.recv_dispatch()

  def send_removeIterator(self, login, tableName, iterName, scopes):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('removeIterator', TMessageType.CALL, self._seqid)
    args = removeIterator_args()
    args.login = login
    args.tableName = tableName
    args.iterName = iterName
    args.scopes = scopes
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_removeIterator(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = removeIterator_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def removeTableProperty(self, login, tableName, property, callback):
    """
    Parameters:
     - login
     - tableName
     - property
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_removeTableProperty(login, tableName, property)
    self.recv_dispatch()

  def send_removeTableProperty(self, login, tableName, property):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('removeTableProperty', TMessageType.CALL, self._seqid)
    args = removeTableProperty_args()
    args.login = login
    args.tableName = tableName
    args.property = property
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_removeTableProperty(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = removeTableProperty_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def renameTable(self, login, oldTableName, newTableName, callback):
    """
    Parameters:
     - login
     - oldTableName
     - newTableName
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_renameTable(login, oldTableName, newTableName)
    self.recv_dispatch()

  def send_renameTable(self, login, oldTableName, newTableName):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('renameTable', TMessageType.CALL, self._seqid)
    args = renameTable_args()
    args.login = login
    args.oldTableName = oldTableName
    args.newTableName = newTableName
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_renameTable(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = renameTable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    if result.ouch4 is not None:
      callback(result.ouch4)
      return
    callback(None)
    return

  def setLocalityGroups(self, login, tableName, groups, callback):
    """
    Parameters:
     - login
     - tableName
     - groups
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_setLocalityGroups(login, tableName, groups)
    self.recv_dispatch()

  def send_setLocalityGroups(self, login, tableName, groups):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('setLocalityGroups', TMessageType.CALL, self._seqid)
    args = setLocalityGroups_args()
    args.login = login
    args.tableName = tableName
    args.groups = groups
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_setLocalityGroups(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = setLocalityGroups_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def setTableProperty(self, login, tableName, property, value, callback):
    """
    Parameters:
     - login
     - tableName
     - property
     - value
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_setTableProperty(login, tableName, property, value)
    self.recv_dispatch()

  def send_setTableProperty(self, login, tableName, property, value):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('setTableProperty', TMessageType.CALL, self._seqid)
    args = setTableProperty_args()
    args.login = login
    args.tableName = tableName
    args.property = property
    args.value = value
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_setTableProperty(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = setTableProperty_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def splitRangeByTablets(self, login, tableName, range, maxSplits, callback):
    """
    Parameters:
     - login
     - tableName
     - range
     - maxSplits
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_splitRangeByTablets(login, tableName, range, maxSplits)
    self.recv_dispatch()

  def send_splitRangeByTablets(self, login, tableName, range, maxSplits):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('splitRangeByTablets', TMessageType.CALL, self._seqid)
    args = splitRangeByTablets_args()
    args.login = login
    args.tableName = tableName
    args.range = range
    args.maxSplits = maxSplits
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_splitRangeByTablets(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = splitRangeByTablets_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "splitRangeByTablets failed: unknown result"))
    return

  def tableExists(self, login, tableName, callback):
    """
    Parameters:
     - login
     - tableName
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_tableExists(login, tableName)
    self.recv_dispatch()

  def send_tableExists(self, login, tableName):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('tableExists', TMessageType.CALL, self._seqid)
    args = tableExists_args()
    args.login = login
    args.tableName = tableName
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_tableExists(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = tableExists_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "tableExists failed: unknown result"))
    return

  def tableIdMap(self, login, callback):
    """
    Parameters:
     - login
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_tableIdMap(login)
    self.recv_dispatch()

  def send_tableIdMap(self, login):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('tableIdMap', TMessageType.CALL, self._seqid)
    args = tableIdMap_args()
    args.login = login
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_tableIdMap(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = tableIdMap_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "tableIdMap failed: unknown result"))
    return

  def testTableClassLoad(self, login, tableName, className, asTypeName, callback):
    """
    Parameters:
     - login
     - tableName
     - className
     - asTypeName
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_testTableClassLoad(login, tableName, className, asTypeName)
    self.recv_dispatch()

  def send_testTableClassLoad(self, login, tableName, className, asTypeName):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testTableClassLoad', TMessageType.CALL, self._seqid)
    args = testTableClassLoad_args()
    args.login = login
    args.tableName = tableName
    args.className = className
    args.asTypeName = asTypeName
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testTableClassLoad(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = testTableClassLoad_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "testTableClassLoad failed: unknown result"))
    return

  def pingTabletServer(self, login, tserver, callback):
    """
    Parameters:
     - login
     - tserver
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_pingTabletServer(login, tserver)
    self.recv_dispatch()

  def send_pingTabletServer(self, login, tserver):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('pingTabletServer', TMessageType.CALL, self._seqid)
    args = pingTabletServer_args()
    args.login = login
    args.tserver = tserver
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_pingTabletServer(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = pingTabletServer_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(None)
    return

  def getActiveScans(self, login, tserver, callback):
    """
    Parameters:
     - login
     - tserver
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_getActiveScans(login, tserver)
    self.recv_dispatch()

  def send_getActiveScans(self, login, tserver):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getActiveScans', TMessageType.CALL, self._seqid)
    args = getActiveScans_args()
    args.login = login
    args.tserver = tserver
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getActiveScans(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = getActiveScans_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "getActiveScans failed: unknown result"))
    return

  def getActiveCompactions(self, login, tserver, callback):
    """
    Parameters:
     - login
     - tserver
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_getActiveCompactions(login, tserver)
    self.recv_dispatch()

  def send_getActiveCompactions(self, login, tserver):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getActiveCompactions', TMessageType.CALL, self._seqid)
    args = getActiveCompactions_args()
    args.login = login
    args.tserver = tserver
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getActiveCompactions(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = getActiveCompactions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "getActiveCompactions failed: unknown result"))
    return

  def getSiteConfiguration(self, login, callback):
    """
    Parameters:
     - login
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_getSiteConfiguration(login)
    self.recv_dispatch()

  def send_getSiteConfiguration(self, login):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getSiteConfiguration', TMessageType.CALL, self._seqid)
    args = getSiteConfiguration_args()
    args.login = login
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getSiteConfiguration(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = getSiteConfiguration_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "getSiteConfiguration failed: unknown result"))
    return

  def getSystemConfiguration(self, login, callback):
    """
    Parameters:
     - login
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_getSystemConfiguration(login)
    self.recv_dispatch()

  def send_getSystemConfiguration(self, login):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getSystemConfiguration', TMessageType.CALL, self._seqid)
    args = getSystemConfiguration_args()
    args.login = login
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getSystemConfiguration(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = getSystemConfiguration_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "getSystemConfiguration failed: unknown result"))
    return

  def getTabletServers(self, login, callback):
    """
    Parameters:
     - login
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_getTabletServers(login)
    self.recv_dispatch()

  def send_getTabletServers(self, login):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getTabletServers', TMessageType.CALL, self._seqid)
    args = getTabletServers_args()
    args.login = login
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getTabletServers(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = getTabletServers_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "getTabletServers failed: unknown result"))
    return

  def removeProperty(self, login, property, callback):
    """
    Parameters:
     - login
     - property
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_removeProperty(login, property)
    self.recv_dispatch()

  def send_removeProperty(self, login, property):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('removeProperty', TMessageType.CALL, self._seqid)
    args = removeProperty_args()
    args.login = login
    args.property = property
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_removeProperty(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = removeProperty_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(None)
    return

  def setProperty(self, login, property, value, callback):
    """
    Parameters:
     - login
     - property
     - value
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_setProperty(login, property, value)
    self.recv_dispatch()

  def send_setProperty(self, login, property, value):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('setProperty', TMessageType.CALL, self._seqid)
    args = setProperty_args()
    args.login = login
    args.property = property
    args.value = value
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_setProperty(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = setProperty_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(None)
    return

  def testClassLoad(self, login, className, asTypeName, callback):
    """
    Parameters:
     - login
     - className
     - asTypeName
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_testClassLoad(login, className, asTypeName)
    self.recv_dispatch()

  def send_testClassLoad(self, login, className, asTypeName):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testClassLoad', TMessageType.CALL, self._seqid)
    args = testClassLoad_args()
    args.login = login
    args.className = className
    args.asTypeName = asTypeName
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testClassLoad(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = testClassLoad_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "testClassLoad failed: unknown result"))
    return

  def authenticateUser(self, login, user, properties, callback):
    """
    Parameters:
     - login
     - user
     - properties
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_authenticateUser(login, user, properties)
    self.recv_dispatch()

  def send_authenticateUser(self, login, user, properties):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('authenticateUser', TMessageType.CALL, self._seqid)
    args = authenticateUser_args()
    args.login = login
    args.user = user
    args.properties = properties
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_authenticateUser(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = authenticateUser_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "authenticateUser failed: unknown result"))
    return

  def changeUserAuthorizations(self, login, user, authorizations, callback):
    """
    Parameters:
     - login
     - user
     - authorizations
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_changeUserAuthorizations(login, user, authorizations)
    self.recv_dispatch()

  def send_changeUserAuthorizations(self, login, user, authorizations):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('changeUserAuthorizations', TMessageType.CALL, self._seqid)
    args = changeUserAuthorizations_args()
    args.login = login
    args.user = user
    args.authorizations = authorizations
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_changeUserAuthorizations(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = changeUserAuthorizations_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(None)
    return

  def changeLocalUserPassword(self, login, user, password, callback):
    """
    Parameters:
     - login
     - user
     - password
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_changeLocalUserPassword(login, user, password)
    self.recv_dispatch()

  def send_changeLocalUserPassword(self, login, user, password):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('changeLocalUserPassword', TMessageType.CALL, self._seqid)
    args = changeLocalUserPassword_args()
    args.login = login
    args.user = user
    args.password = password
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_changeLocalUserPassword(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = changeLocalUserPassword_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(None)
    return

  def createLocalUser(self, login, user, password, callback):
    """
    Parameters:
     - login
     - user
     - password
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_createLocalUser(login, user, password)
    self.recv_dispatch()

  def send_createLocalUser(self, login, user, password):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('createLocalUser', TMessageType.CALL, self._seqid)
    args = createLocalUser_args()
    args.login = login
    args.user = user
    args.password = password
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_createLocalUser(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = createLocalUser_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(None)
    return

  def dropLocalUser(self, login, user, callback):
    """
    Parameters:
     - login
     - user
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_dropLocalUser(login, user)
    self.recv_dispatch()

  def send_dropLocalUser(self, login, user):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('dropLocalUser', TMessageType.CALL, self._seqid)
    args = dropLocalUser_args()
    args.login = login
    args.user = user
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_dropLocalUser(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = dropLocalUser_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(None)
    return

  def getUserAuthorizations(self, login, user, callback):
    """
    Parameters:
     - login
     - user
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_getUserAuthorizations(login, user)
    self.recv_dispatch()

  def send_getUserAuthorizations(self, login, user):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getUserAuthorizations', TMessageType.CALL, self._seqid)
    args = getUserAuthorizations_args()
    args.login = login
    args.user = user
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getUserAuthorizations(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = getUserAuthorizations_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "getUserAuthorizations failed: unknown result"))
    return

  def grantSystemPermission(self, login, user, perm, callback):
    """
    Parameters:
     - login
     - user
     - perm
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_grantSystemPermission(login, user, perm)
    self.recv_dispatch()

  def send_grantSystemPermission(self, login, user, perm):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('grantSystemPermission', TMessageType.CALL, self._seqid)
    args = grantSystemPermission_args()
    args.login = login
    args.user = user
    args.perm = perm
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_grantSystemPermission(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = grantSystemPermission_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(None)
    return

  def grantTablePermission(self, login, user, table, perm, callback):
    """
    Parameters:
     - login
     - user
     - table
     - perm
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_grantTablePermission(login, user, table, perm)
    self.recv_dispatch()

  def send_grantTablePermission(self, login, user, table, perm):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('grantTablePermission', TMessageType.CALL, self._seqid)
    args = grantTablePermission_args()
    args.login = login
    args.user = user
    args.table = table
    args.perm = perm
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_grantTablePermission(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = grantTablePermission_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def hasSystemPermission(self, login, user, perm, callback):
    """
    Parameters:
     - login
     - user
     - perm
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_hasSystemPermission(login, user, perm)
    self.recv_dispatch()

  def send_hasSystemPermission(self, login, user, perm):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('hasSystemPermission', TMessageType.CALL, self._seqid)
    args = hasSystemPermission_args()
    args.login = login
    args.user = user
    args.perm = perm
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_hasSystemPermission(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = hasSystemPermission_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "hasSystemPermission failed: unknown result"))
    return

  def hasTablePermission(self, login, user, table, perm, callback):
    """
    Parameters:
     - login
     - user
     - table
     - perm
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_hasTablePermission(login, user, table, perm)
    self.recv_dispatch()

  def send_hasTablePermission(self, login, user, table, perm):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('hasTablePermission', TMessageType.CALL, self._seqid)
    args = hasTablePermission_args()
    args.login = login
    args.user = user
    args.table = table
    args.perm = perm
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_hasTablePermission(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = hasTablePermission_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "hasTablePermission failed: unknown result"))
    return

  def listLocalUsers(self, login, callback):
    """
    Parameters:
     - login
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_listLocalUsers(login)
    self.recv_dispatch()

  def send_listLocalUsers(self, login):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('listLocalUsers', TMessageType.CALL, self._seqid)
    args = listLocalUsers_args()
    args.login = login
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_listLocalUsers(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = listLocalUsers_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "listLocalUsers failed: unknown result"))
    return

  def revokeSystemPermission(self, login, user, perm, callback):
    """
    Parameters:
     - login
     - user
     - perm
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_revokeSystemPermission(login, user, perm)
    self.recv_dispatch()

  def send_revokeSystemPermission(self, login, user, perm):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('revokeSystemPermission', TMessageType.CALL, self._seqid)
    args = revokeSystemPermission_args()
    args.login = login
    args.user = user
    args.perm = perm
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_revokeSystemPermission(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = revokeSystemPermission_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(None)
    return

  def revokeTablePermission(self, login, user, table, perm, callback):
    """
    Parameters:
     - login
     - user
     - table
     - perm
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_revokeTablePermission(login, user, table, perm)
    self.recv_dispatch()

  def send_revokeTablePermission(self, login, user, table, perm):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('revokeTablePermission', TMessageType.CALL, self._seqid)
    args = revokeTablePermission_args()
    args.login = login
    args.user = user
    args.table = table
    args.perm = perm
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_revokeTablePermission(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = revokeTablePermission_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(None)
    return

  def createBatchScanner(self, login, tableName, options, callback):
    """
    Parameters:
     - login
     - tableName
     - options
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_createBatchScanner(login, tableName, options)
    self.recv_dispatch()

  def send_createBatchScanner(self, login, tableName, options):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('createBatchScanner', TMessageType.CALL, self._seqid)
    args = createBatchScanner_args()
    args.login = login
    args.tableName = tableName
    args.options = options
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_createBatchScanner(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = createBatchScanner_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "createBatchScanner failed: unknown result"))
    return

  def createScanner(self, login, tableName, options, callback):
    """
    Parameters:
     - login
     - tableName
     - options
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_createScanner(login, tableName, options)
    self.recv_dispatch()

  def send_createScanner(self, login, tableName, options):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('createScanner', TMessageType.CALL, self._seqid)
    args = createScanner_args()
    args.login = login
    args.tableName = tableName
    args.options = options
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_createScanner(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = createScanner_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "createScanner failed: unknown result"))
    return

  def hasNext(self, scanner, callback):
    """
    Parameters:
     - scanner
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_hasNext(scanner)
    self.recv_dispatch()

  def send_hasNext(self, scanner):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('hasNext', TMessageType.CALL, self._seqid)
    args = hasNext_args()
    args.scanner = scanner
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_hasNext(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = hasNext_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "hasNext failed: unknown result"))
    return

  def nextEntry(self, scanner, callback):
    """
    Parameters:
     - scanner
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_nextEntry(scanner)
    self.recv_dispatch()

  def send_nextEntry(self, scanner):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('nextEntry', TMessageType.CALL, self._seqid)
    args = nextEntry_args()
    args.scanner = scanner
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_nextEntry(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = nextEntry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "nextEntry failed: unknown result"))
    return

  def nextK(self, scanner, k, callback):
    """
    Parameters:
     - scanner
     - k
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_nextK(scanner, k)
    self.recv_dispatch()

  def send_nextK(self, scanner, k):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('nextK', TMessageType.CALL, self._seqid)
    args = nextK_args()
    args.scanner = scanner
    args.k = k
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_nextK(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = nextK_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "nextK failed: unknown result"))
    return

  def closeScanner(self, scanner, callback):
    """
    Parameters:
     - scanner
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_closeScanner(scanner)
    self.recv_dispatch()

  def send_closeScanner(self, scanner):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('closeScanner', TMessageType.CALL, self._seqid)
    args = closeScanner_args()
    args.scanner = scanner
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_closeScanner(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = closeScanner_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    callback(None)
    return

  def updateAndFlush(self, login, tableName, cells, callback):
    """
    Parameters:
     - login
     - tableName
     - cells
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_updateAndFlush(login, tableName, cells)
    self.recv_dispatch()

  def send_updateAndFlush(self, login, tableName, cells):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('updateAndFlush', TMessageType.CALL, self._seqid)
    args = updateAndFlush_args()
    args.login = login
    args.tableName = tableName
    args.cells = cells
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_updateAndFlush(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = updateAndFlush_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.outch1 is not None:
      callback(result.outch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    if result.ouch4 is not None:
      callback(result.ouch4)
      return
    callback(None)
    return

  def createWriter(self, login, tableName, opts, callback):
    """
    Parameters:
     - login
     - tableName
     - opts
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_createWriter(login, tableName, opts)
    self.recv_dispatch()

  def send_createWriter(self, login, tableName, opts):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('createWriter', TMessageType.CALL, self._seqid)
    args = createWriter_args()
    args.login = login
    args.tableName = tableName
    args.opts = opts
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_createWriter(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = createWriter_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.outch1 is not None:
      callback(result.outch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "createWriter failed: unknown result"))
    return

  def update(self, writer, cells, callback=None):
    """
    Parameters:
     - writer
     - cells
    """
    self._seqid += 1
    self.send_update(writer, cells, callback)

  def send_update(self, writer, cells, callback):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('update', TMessageType.CALL, self._seqid)
    args = update_args()
    args.writer = writer
    args.cells = cells
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush(callback=callback)
  def flush(self, writer, callback):
    """
    Parameters:
     - writer
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_flush(writer)
    self.recv_dispatch()

  def send_flush(self, writer):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('flush', TMessageType.CALL, self._seqid)
    args = flush_args()
    args.writer = writer
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_flush(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = flush_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(None)
    return

  def closeWriter(self, writer, callback):
    """
    Parameters:
     - writer
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_closeWriter(writer)
    self.recv_dispatch()

  def send_closeWriter(self, writer):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('closeWriter', TMessageType.CALL, self._seqid)
    args = closeWriter_args()
    args.writer = writer
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_closeWriter(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = closeWriter_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    callback(None)
    return

  def updateRowConditionally(self, login, tableName, row, updates, callback):
    """
    Parameters:
     - login
     - tableName
     - row
     - updates
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_updateRowConditionally(login, tableName, row, updates)
    self.recv_dispatch()

  def send_updateRowConditionally(self, login, tableName, row, updates):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('updateRowConditionally', TMessageType.CALL, self._seqid)
    args = updateRowConditionally_args()
    args.login = login
    args.tableName = tableName
    args.row = row
    args.updates = updates
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_updateRowConditionally(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = updateRowConditionally_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "updateRowConditionally failed: unknown result"))
    return

  def createConditionalWriter(self, login, tableName, options, callback):
    """
    Parameters:
     - login
     - tableName
     - options
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_createConditionalWriter(login, tableName, options)
    self.recv_dispatch()

  def send_createConditionalWriter(self, login, tableName, options):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('createConditionalWriter', TMessageType.CALL, self._seqid)
    args = createConditionalWriter_args()
    args.login = login
    args.tableName = tableName
    args.options = options
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_createConditionalWriter(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = createConditionalWriter_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "createConditionalWriter failed: unknown result"))
    return

  def updateRowsConditionally(self, conditionalWriter, updates, callback):
    """
    Parameters:
     - conditionalWriter
     - updates
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_updateRowsConditionally(conditionalWriter, updates)
    self.recv_dispatch()

  def send_updateRowsConditionally(self, conditionalWriter, updates):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('updateRowsConditionally', TMessageType.CALL, self._seqid)
    args = updateRowsConditionally_args()
    args.conditionalWriter = conditionalWriter
    args.updates = updates
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_updateRowsConditionally(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = updateRowsConditionally_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    if result.ouch1 is not None:
      callback(result.ouch1)
      return
    if result.ouch2 is not None:
      callback(result.ouch2)
      return
    if result.ouch3 is not None:
      callback(result.ouch3)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "updateRowsConditionally failed: unknown result"))
    return

  def closeConditionalWriter(self, conditionalWriter, callback):
    """
    Parameters:
     - conditionalWriter
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_closeConditionalWriter(conditionalWriter)
    self.recv_dispatch()

  def send_closeConditionalWriter(self, conditionalWriter):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('closeConditionalWriter', TMessageType.CALL, self._seqid)
    args = closeConditionalWriter_args()
    args.conditionalWriter = conditionalWriter
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_closeConditionalWriter(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = closeConditionalWriter_result()
    result.read(iprot)
    iprot.readMessageEnd()
    callback(None)
    return

  def getRowRange(self, row, callback):
    """
    Parameters:
     - row
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_getRowRange(row)
    self.recv_dispatch()

  def send_getRowRange(self, row):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getRowRange', TMessageType.CALL, self._seqid)
    args = getRowRange_args()
    args.row = row
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getRowRange(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = getRowRange_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "getRowRange failed: unknown result"))
    return

  def getFollowing(self, key, part, callback):
    """
    Parameters:
     - key
     - part
    """
    self._seqid += 1
    self._reqs[self._seqid] = callback
    self.send_getFollowing(key, part)
    self.recv_dispatch()

  def send_getFollowing(self, key, part):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('getFollowing', TMessageType.CALL, self._seqid)
    args = getFollowing_args()
    args.key = key
    args.part = part
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_getFollowing(self, iprot, mtype, rseqid):
    callback = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      callback(x)
      return
    result = getFollowing_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      callback(result.success)
      return
    callback(TApplicationException(TApplicationException.MISSING_RESULT, "getFollowing failed: unknown result"))
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["login"] = Processor.process_login
    self._processMap["addConstraint"] = Processor.process_addConstraint
    self._processMap["addSplits"] = Processor.process_addSplits
    self._processMap["attachIterator"] = Processor.process_attachIterator
    self._processMap["checkIteratorConflicts"] = Processor.process_checkIteratorConflicts
    self._processMap["clearLocatorCache"] = Processor.process_clearLocatorCache
    self._processMap["cloneTable"] = Processor.process_cloneTable
    self._processMap["compactTable"] = Processor.process_compactTable
    self._processMap["cancelCompaction"] = Processor.process_cancelCompaction
    self._processMap["createTable"] = Processor.process_createTable
    self._processMap["deleteTable"] = Processor.process_deleteTable
    self._processMap["deleteRows"] = Processor.process_deleteRows
    self._processMap["exportTable"] = Processor.process_exportTable
    self._processMap["flushTable"] = Processor.process_flushTable
    self._processMap["getDiskUsage"] = Processor.process_getDiskUsage
    self._processMap["getLocalityGroups"] = Processor.process_getLocalityGroups
    self._processMap["getIteratorSetting"] = Processor.process_getIteratorSetting
    self._processMap["getMaxRow"] = Processor.process_getMaxRow
    self._processMap["getTableProperties"] = Processor.process_getTableProperties
    self._processMap["importDirectory"] = Processor.process_importDirectory
    self._processMap["importTable"] = Processor.process_importTable
    self._processMap["listSplits"] = Processor.process_listSplits
    self._processMap["listTables"] = Processor.process_listTables
    self._processMap["listIterators"] = Processor.process_listIterators
    self._processMap["listConstraints"] = Processor.process_listConstraints
    self._processMap["mergeTablets"] = Processor.process_mergeTablets
    self._processMap["offlineTable"] = Processor.process_offlineTable
    self._processMap["onlineTable"] = Processor.process_onlineTable
    self._processMap["removeConstraint"] = Processor.process_removeConstraint
    self._processMap["removeIterator"] = Processor.process_removeIterator
    self._processMap["removeTableProperty"] = Processor.process_removeTableProperty
    self._processMap["renameTable"] = Processor.process_renameTable
    self._processMap["setLocalityGroups"] = Processor.process_setLocalityGroups
    self._processMap["setTableProperty"] = Processor.process_setTableProperty
    self._processMap["splitRangeByTablets"] = Processor.process_splitRangeByTablets
    self._processMap["tableExists"] = Processor.process_tableExists
    self._processMap["tableIdMap"] = Processor.process_tableIdMap
    self._processMap["testTableClassLoad"] = Processor.process_testTableClassLoad
    self._processMap["pingTabletServer"] = Processor.process_pingTabletServer
    self._processMap["getActiveScans"] = Processor.process_getActiveScans
    self._processMap["getActiveCompactions"] = Processor.process_getActiveCompactions
    self._processMap["getSiteConfiguration"] = Processor.process_getSiteConfiguration
    self._processMap["getSystemConfiguration"] = Processor.process_getSystemConfiguration
    self._processMap["getTabletServers"] = Processor.process_getTabletServers
    self._processMap["removeProperty"] = Processor.process_removeProperty
    self._processMap["setProperty"] = Processor.process_setProperty
    self._processMap["testClassLoad"] = Processor.process_testClassLoad
    self._processMap["authenticateUser"] = Processor.process_authenticateUser
    self._processMap["changeUserAuthorizations"] = Processor.process_changeUserAuthorizations
    self._processMap["changeLocalUserPassword"] = Processor.process_changeLocalUserPassword
    self._processMap["createLocalUser"] = Processor.process_createLocalUser
    self._processMap["dropLocalUser"] = Processor.process_dropLocalUser
    self._processMap["getUserAuthorizations"] = Processor.process_getUserAuthorizations
    self._processMap["grantSystemPermission"] = Processor.process_grantSystemPermission
    self._processMap["grantTablePermission"] = Processor.process_grantTablePermission
    self._processMap["hasSystemPermission"] = Processor.process_hasSystemPermission
    self._processMap["hasTablePermission"] = Processor.process_hasTablePermission
    self._processMap["listLocalUsers"] = Processor.process_listLocalUsers
    self._processMap["revokeSystemPermission"] = Processor.process_revokeSystemPermission
    self._processMap["revokeTablePermission"] = Processor.process_revokeTablePermission
    self._processMap["createBatchScanner"] = Processor.process_createBatchScanner
    self._processMap["createScanner"] = Processor.process_createScanner
    self._processMap["hasNext"] = Processor.process_hasNext
    self._processMap["nextEntry"] = Processor.process_nextEntry
    self._processMap["nextK"] = Processor.process_nextK
    self._processMap["closeScanner"] = Processor.process_closeScanner
    self._processMap["updateAndFlush"] = Processor.process_updateAndFlush
    self._processMap["createWriter"] = Processor.process_createWriter
    self._processMap["update"] = Processor.process_update
    self._processMap["flush"] = Processor.process_flush
    self._processMap["closeWriter"] = Processor.process_closeWriter
    self._processMap["updateRowConditionally"] = Processor.process_updateRowConditionally
    self._processMap["createConditionalWriter"] = Processor.process_createConditionalWriter
    self._processMap["updateRowsConditionally"] = Processor.process_updateRowsConditionally
    self._processMap["closeConditionalWriter"] = Processor.process_closeConditionalWriter
    self._processMap["getRowRange"] = Processor.process_getRowRange
    self._processMap["getFollowing"] = Processor.process_getFollowing

  @gen.engine
  def process(self, transport, iprot_factory, oprot, callback):
    # wait for a frame header
    frame = yield gen.Task(transport.readFrame)
    tr = TTransport.TMemoryBuffer(frame)
    iprot = iprot_factory.getProtocol(tr)

    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
    else:
      yield gen.Task(self._processMap[name], self, seqid, iprot, oprot)
    callback()

  @gen.engine
  def process_login(self, seqid, iprot, oprot, callback):
    args = login_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = login_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.login, args.principal, args.loginProperties)

    oprot.writeMessageBegin("login", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_addConstraint(self, seqid, iprot, oprot, callback):
    args = addConstraint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addConstraint_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.addConstraint, args.login, args.tableName, args.constraintClassName)

    oprot.writeMessageBegin("addConstraint", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_addSplits(self, seqid, iprot, oprot, callback):
    args = addSplits_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addSplits_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.addSplits, args.login, args.tableName, args.splits)

    oprot.writeMessageBegin("addSplits", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_attachIterator(self, seqid, iprot, oprot, callback):
    args = attachIterator_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = attachIterator_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloSecurityException:
        result.ouch1 = value
        return True
      if xtype == AccumuloException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.attachIterator, args.login, args.tableName, args.setting, args.scopes)

    oprot.writeMessageBegin("attachIterator", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_checkIteratorConflicts(self, seqid, iprot, oprot, callback):
    args = checkIteratorConflicts_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = checkIteratorConflicts_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloSecurityException:
        result.ouch1 = value
        return True
      if xtype == AccumuloException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.checkIteratorConflicts, args.login, args.tableName, args.setting, args.scopes)

    oprot.writeMessageBegin("checkIteratorConflicts", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_clearLocatorCache(self, seqid, iprot, oprot, callback):
    args = clearLocatorCache_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearLocatorCache_result()

    def handle_exception(xtype, value, traceback):
      if xtype == TableNotFoundException:
        result.ouch1 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.clearLocatorCache, args.login, args.tableName)

    oprot.writeMessageBegin("clearLocatorCache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_cloneTable(self, seqid, iprot, oprot, callback):
    args = cloneTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cloneTable_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True
      if xtype == TableExistsException:
        result.ouch4 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.cloneTable, args.login, args.tableName, args.newTableName, args.flush, args.propertiesToSet, args.propertiesToExclude)

    oprot.writeMessageBegin("cloneTable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_compactTable(self, seqid, iprot, oprot, callback):
    args = compactTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = compactTable_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloSecurityException:
        result.ouch1 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch2 = value
        return True
      if xtype == AccumuloException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.compactTable, args.login, args.tableName, args.startRow, args.endRow, args.iterators, args.flush, args.wait)

    oprot.writeMessageBegin("compactTable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_cancelCompaction(self, seqid, iprot, oprot, callback):
    args = cancelCompaction_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cancelCompaction_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloSecurityException:
        result.ouch1 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch2 = value
        return True
      if xtype == AccumuloException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.cancelCompaction, args.login, args.tableName)

    oprot.writeMessageBegin("cancelCompaction", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_createTable(self, seqid, iprot, oprot, callback):
    args = createTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createTable_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableExistsException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.createTable, args.login, args.tableName, args.versioningIter, args.type)

    oprot.writeMessageBegin("createTable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_deleteTable(self, seqid, iprot, oprot, callback):
    args = deleteTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteTable_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.deleteTable, args.login, args.tableName)

    oprot.writeMessageBegin("deleteTable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_deleteRows(self, seqid, iprot, oprot, callback):
    args = deleteRows_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteRows_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.deleteRows, args.login, args.tableName, args.startRow, args.endRow)

    oprot.writeMessageBegin("deleteRows", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_exportTable(self, seqid, iprot, oprot, callback):
    args = exportTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = exportTable_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.exportTable, args.login, args.tableName, args.exportDir)

    oprot.writeMessageBegin("exportTable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_flushTable(self, seqid, iprot, oprot, callback):
    args = flushTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = flushTable_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.flushTable, args.login, args.tableName, args.startRow, args.endRow, args.wait)

    oprot.writeMessageBegin("flushTable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_getDiskUsage(self, seqid, iprot, oprot, callback):
    args = getDiskUsage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDiskUsage_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.getDiskUsage, args.login, args.tables)

    oprot.writeMessageBegin("getDiskUsage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_getLocalityGroups(self, seqid, iprot, oprot, callback):
    args = getLocalityGroups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLocalityGroups_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.getLocalityGroups, args.login, args.tableName)

    oprot.writeMessageBegin("getLocalityGroups", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_getIteratorSetting(self, seqid, iprot, oprot, callback):
    args = getIteratorSetting_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getIteratorSetting_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.getIteratorSetting, args.login, args.tableName, args.iteratorName, args.scope)

    oprot.writeMessageBegin("getIteratorSetting", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_getMaxRow(self, seqid, iprot, oprot, callback):
    args = getMaxRow_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getMaxRow_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.getMaxRow, args.login, args.tableName, args.auths, args.startRow, args.startInclusive, args.endRow, args.endInclusive)

    oprot.writeMessageBegin("getMaxRow", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_getTableProperties(self, seqid, iprot, oprot, callback):
    args = getTableProperties_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTableProperties_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.getTableProperties, args.login, args.tableName)

    oprot.writeMessageBegin("getTableProperties", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_importDirectory(self, seqid, iprot, oprot, callback):
    args = importDirectory_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = importDirectory_result()

    def handle_exception(xtype, value, traceback):
      if xtype == TableNotFoundException:
        result.ouch1 = value
        return True
      if xtype == AccumuloException:
        result.ouch3 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch4 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.importDirectory, args.login, args.tableName, args.importDir, args.failureDir, args.setTime)

    oprot.writeMessageBegin("importDirectory", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_importTable(self, seqid, iprot, oprot, callback):
    args = importTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = importTable_result()

    def handle_exception(xtype, value, traceback):
      if xtype == TableExistsException:
        result.ouch1 = value
        return True
      if xtype == AccumuloException:
        result.ouch2 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.importTable, args.login, args.tableName, args.importDir)

    oprot.writeMessageBegin("importTable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_listSplits(self, seqid, iprot, oprot, callback):
    args = listSplits_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSplits_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.listSplits, args.login, args.tableName, args.maxSplits)

    oprot.writeMessageBegin("listSplits", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_listTables(self, seqid, iprot, oprot, callback):
    args = listTables_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listTables_result()
    result.success = yield gen.Task(self._handler.listTables, args.login)
    oprot.writeMessageBegin("listTables", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_listIterators(self, seqid, iprot, oprot, callback):
    args = listIterators_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listIterators_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.listIterators, args.login, args.tableName)

    oprot.writeMessageBegin("listIterators", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_listConstraints(self, seqid, iprot, oprot, callback):
    args = listConstraints_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listConstraints_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.listConstraints, args.login, args.tableName)

    oprot.writeMessageBegin("listConstraints", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_mergeTablets(self, seqid, iprot, oprot, callback):
    args = mergeTablets_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = mergeTablets_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.mergeTablets, args.login, args.tableName, args.startRow, args.endRow)

    oprot.writeMessageBegin("mergeTablets", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_offlineTable(self, seqid, iprot, oprot, callback):
    args = offlineTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = offlineTable_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.offlineTable, args.login, args.tableName, args.wait)

    oprot.writeMessageBegin("offlineTable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_onlineTable(self, seqid, iprot, oprot, callback):
    args = onlineTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = onlineTable_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.onlineTable, args.login, args.tableName, args.wait)

    oprot.writeMessageBegin("onlineTable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_removeConstraint(self, seqid, iprot, oprot, callback):
    args = removeConstraint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeConstraint_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.removeConstraint, args.login, args.tableName, args.constraint)

    oprot.writeMessageBegin("removeConstraint", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_removeIterator(self, seqid, iprot, oprot, callback):
    args = removeIterator_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeIterator_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.removeIterator, args.login, args.tableName, args.iterName, args.scopes)

    oprot.writeMessageBegin("removeIterator", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_removeTableProperty(self, seqid, iprot, oprot, callback):
    args = removeTableProperty_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeTableProperty_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.removeTableProperty, args.login, args.tableName, args.property)

    oprot.writeMessageBegin("removeTableProperty", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_renameTable(self, seqid, iprot, oprot, callback):
    args = renameTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = renameTable_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True
      if xtype == TableExistsException:
        result.ouch4 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.renameTable, args.login, args.oldTableName, args.newTableName)

    oprot.writeMessageBegin("renameTable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_setLocalityGroups(self, seqid, iprot, oprot, callback):
    args = setLocalityGroups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setLocalityGroups_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.setLocalityGroups, args.login, args.tableName, args.groups)

    oprot.writeMessageBegin("setLocalityGroups", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_setTableProperty(self, seqid, iprot, oprot, callback):
    args = setTableProperty_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setTableProperty_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.setTableProperty, args.login, args.tableName, args.property, args.value)

    oprot.writeMessageBegin("setTableProperty", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_splitRangeByTablets(self, seqid, iprot, oprot, callback):
    args = splitRangeByTablets_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = splitRangeByTablets_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.splitRangeByTablets, args.login, args.tableName, args.range, args.maxSplits)

    oprot.writeMessageBegin("splitRangeByTablets", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_tableExists(self, seqid, iprot, oprot, callback):
    args = tableExists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tableExists_result()
    result.success = yield gen.Task(self._handler.tableExists, args.login, args.tableName)
    oprot.writeMessageBegin("tableExists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_tableIdMap(self, seqid, iprot, oprot, callback):
    args = tableIdMap_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = tableIdMap_result()
    result.success = yield gen.Task(self._handler.tableIdMap, args.login)
    oprot.writeMessageBegin("tableIdMap", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_testTableClassLoad(self, seqid, iprot, oprot, callback):
    args = testTableClassLoad_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testTableClassLoad_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.testTableClassLoad, args.login, args.tableName, args.className, args.asTypeName)

    oprot.writeMessageBegin("testTableClassLoad", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_pingTabletServer(self, seqid, iprot, oprot, callback):
    args = pingTabletServer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pingTabletServer_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.pingTabletServer, args.login, args.tserver)

    oprot.writeMessageBegin("pingTabletServer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_getActiveScans(self, seqid, iprot, oprot, callback):
    args = getActiveScans_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getActiveScans_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.getActiveScans, args.login, args.tserver)

    oprot.writeMessageBegin("getActiveScans", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_getActiveCompactions(self, seqid, iprot, oprot, callback):
    args = getActiveCompactions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getActiveCompactions_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.getActiveCompactions, args.login, args.tserver)

    oprot.writeMessageBegin("getActiveCompactions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_getSiteConfiguration(self, seqid, iprot, oprot, callback):
    args = getSiteConfiguration_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSiteConfiguration_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.getSiteConfiguration, args.login)

    oprot.writeMessageBegin("getSiteConfiguration", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_getSystemConfiguration(self, seqid, iprot, oprot, callback):
    args = getSystemConfiguration_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSystemConfiguration_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.getSystemConfiguration, args.login)

    oprot.writeMessageBegin("getSystemConfiguration", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_getTabletServers(self, seqid, iprot, oprot, callback):
    args = getTabletServers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTabletServers_result()
    result.success = yield gen.Task(self._handler.getTabletServers, args.login)
    oprot.writeMessageBegin("getTabletServers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_removeProperty(self, seqid, iprot, oprot, callback):
    args = removeProperty_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeProperty_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.removeProperty, args.login, args.property)

    oprot.writeMessageBegin("removeProperty", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_setProperty(self, seqid, iprot, oprot, callback):
    args = setProperty_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setProperty_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.setProperty, args.login, args.property, args.value)

    oprot.writeMessageBegin("setProperty", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_testClassLoad(self, seqid, iprot, oprot, callback):
    args = testClassLoad_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testClassLoad_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.testClassLoad, args.login, args.className, args.asTypeName)

    oprot.writeMessageBegin("testClassLoad", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_authenticateUser(self, seqid, iprot, oprot, callback):
    args = authenticateUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authenticateUser_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.authenticateUser, args.login, args.user, args.properties)

    oprot.writeMessageBegin("authenticateUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_changeUserAuthorizations(self, seqid, iprot, oprot, callback):
    args = changeUserAuthorizations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = changeUserAuthorizations_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.changeUserAuthorizations, args.login, args.user, args.authorizations)

    oprot.writeMessageBegin("changeUserAuthorizations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_changeLocalUserPassword(self, seqid, iprot, oprot, callback):
    args = changeLocalUserPassword_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = changeLocalUserPassword_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.changeLocalUserPassword, args.login, args.user, args.password)

    oprot.writeMessageBegin("changeLocalUserPassword", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_createLocalUser(self, seqid, iprot, oprot, callback):
    args = createLocalUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createLocalUser_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.createLocalUser, args.login, args.user, args.password)

    oprot.writeMessageBegin("createLocalUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_dropLocalUser(self, seqid, iprot, oprot, callback):
    args = dropLocalUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = dropLocalUser_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.dropLocalUser, args.login, args.user)

    oprot.writeMessageBegin("dropLocalUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_getUserAuthorizations(self, seqid, iprot, oprot, callback):
    args = getUserAuthorizations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUserAuthorizations_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.getUserAuthorizations, args.login, args.user)

    oprot.writeMessageBegin("getUserAuthorizations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_grantSystemPermission(self, seqid, iprot, oprot, callback):
    args = grantSystemPermission_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grantSystemPermission_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.grantSystemPermission, args.login, args.user, args.perm)

    oprot.writeMessageBegin("grantSystemPermission", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_grantTablePermission(self, seqid, iprot, oprot, callback):
    args = grantTablePermission_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grantTablePermission_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.grantTablePermission, args.login, args.user, args.table, args.perm)

    oprot.writeMessageBegin("grantTablePermission", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_hasSystemPermission(self, seqid, iprot, oprot, callback):
    args = hasSystemPermission_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = hasSystemPermission_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.hasSystemPermission, args.login, args.user, args.perm)

    oprot.writeMessageBegin("hasSystemPermission", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_hasTablePermission(self, seqid, iprot, oprot, callback):
    args = hasTablePermission_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = hasTablePermission_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.hasTablePermission, args.login, args.user, args.table, args.perm)

    oprot.writeMessageBegin("hasTablePermission", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_listLocalUsers(self, seqid, iprot, oprot, callback):
    args = listLocalUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listLocalUsers_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.listLocalUsers, args.login)

    oprot.writeMessageBegin("listLocalUsers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_revokeSystemPermission(self, seqid, iprot, oprot, callback):
    args = revokeSystemPermission_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revokeSystemPermission_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.revokeSystemPermission, args.login, args.user, args.perm)

    oprot.writeMessageBegin("revokeSystemPermission", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_revokeTablePermission(self, seqid, iprot, oprot, callback):
    args = revokeTablePermission_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revokeTablePermission_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.revokeTablePermission, args.login, args.user, args.table, args.perm)

    oprot.writeMessageBegin("revokeTablePermission", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_createBatchScanner(self, seqid, iprot, oprot, callback):
    args = createBatchScanner_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createBatchScanner_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.createBatchScanner, args.login, args.tableName, args.options)

    oprot.writeMessageBegin("createBatchScanner", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_createScanner(self, seqid, iprot, oprot, callback):
    args = createScanner_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createScanner_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.createScanner, args.login, args.tableName, args.options)

    oprot.writeMessageBegin("createScanner", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_hasNext(self, seqid, iprot, oprot, callback):
    args = hasNext_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = hasNext_result()

    def handle_exception(xtype, value, traceback):
      if xtype == UnknownScanner:
        result.ouch1 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.hasNext, args.scanner)

    oprot.writeMessageBegin("hasNext", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_nextEntry(self, seqid, iprot, oprot, callback):
    args = nextEntry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = nextEntry_result()

    def handle_exception(xtype, value, traceback):
      if xtype == NoMoreEntriesException:
        result.ouch1 = value
        return True
      if xtype == UnknownScanner:
        result.ouch2 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.nextEntry, args.scanner)

    oprot.writeMessageBegin("nextEntry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_nextK(self, seqid, iprot, oprot, callback):
    args = nextK_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = nextK_result()

    def handle_exception(xtype, value, traceback):
      if xtype == NoMoreEntriesException:
        result.ouch1 = value
        return True
      if xtype == UnknownScanner:
        result.ouch2 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.nextK, args.scanner, args.k)

    oprot.writeMessageBegin("nextK", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_closeScanner(self, seqid, iprot, oprot, callback):
    args = closeScanner_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = closeScanner_result()

    def handle_exception(xtype, value, traceback):
      if xtype == UnknownScanner:
        result.ouch1 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.closeScanner, args.scanner)

    oprot.writeMessageBegin("closeScanner", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_updateAndFlush(self, seqid, iprot, oprot, callback):
    args = updateAndFlush_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateAndFlush_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.outch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True
      if xtype == MutationsRejectedException:
        result.ouch4 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.updateAndFlush, args.login, args.tableName, args.cells)

    oprot.writeMessageBegin("updateAndFlush", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_createWriter(self, seqid, iprot, oprot, callback):
    args = createWriter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createWriter_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.outch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.createWriter, args.login, args.tableName, args.opts)

    oprot.writeMessageBegin("createWriter", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_update(self, seqid, iprot, oprot, callback):
    args = update_args()
    args.read(iprot)
    iprot.readMessageEnd()
    yield gen.Task(self._handler.update, args.writer, args.cells)
    callback()

  @gen.engine
  def process_flush(self, seqid, iprot, oprot, callback):
    args = flush_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = flush_result()

    def handle_exception(xtype, value, traceback):
      if xtype == UnknownWriter:
        result.ouch1 = value
        return True
      if xtype == MutationsRejectedException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.flush, args.writer)

    oprot.writeMessageBegin("flush", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_closeWriter(self, seqid, iprot, oprot, callback):
    args = closeWriter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = closeWriter_result()

    def handle_exception(xtype, value, traceback):
      if xtype == UnknownWriter:
        result.ouch1 = value
        return True
      if xtype == MutationsRejectedException:
        result.ouch2 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      yield gen.Task(self._handler.closeWriter, args.writer)

    oprot.writeMessageBegin("closeWriter", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_updateRowConditionally(self, seqid, iprot, oprot, callback):
    args = updateRowConditionally_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateRowConditionally_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.updateRowConditionally, args.login, args.tableName, args.row, args.updates)

    oprot.writeMessageBegin("updateRowConditionally", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_createConditionalWriter(self, seqid, iprot, oprot, callback):
    args = createConditionalWriter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createConditionalWriter_result()

    def handle_exception(xtype, value, traceback):
      if xtype == AccumuloException:
        result.ouch1 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch2 = value
        return True
      if xtype == TableNotFoundException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.createConditionalWriter, args.login, args.tableName, args.options)

    oprot.writeMessageBegin("createConditionalWriter", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_updateRowsConditionally(self, seqid, iprot, oprot, callback):
    args = updateRowsConditionally_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateRowsConditionally_result()

    def handle_exception(xtype, value, traceback):
      if xtype == UnknownWriter:
        result.ouch1 = value
        return True
      if xtype == AccumuloException:
        result.ouch2 = value
        return True
      if xtype == AccumuloSecurityException:
        result.ouch3 = value
        return True

    with stack_context.ExceptionStackContext(handle_exception):
      result.success = yield gen.Task(self._handler.updateRowsConditionally, args.conditionalWriter, args.updates)

    oprot.writeMessageBegin("updateRowsConditionally", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_closeConditionalWriter(self, seqid, iprot, oprot, callback):
    args = closeConditionalWriter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = closeConditionalWriter_result()
    yield gen.Task(self._handler.closeConditionalWriter, args.conditionalWriter)
    oprot.writeMessageBegin("closeConditionalWriter", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_getRowRange(self, seqid, iprot, oprot, callback):
    args = getRowRange_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRowRange_result()
    result.success = yield gen.Task(self._handler.getRowRange, args.row)
    oprot.writeMessageBegin("getRowRange", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()

  @gen.engine
  def process_getFollowing(self, seqid, iprot, oprot, callback):
    args = getFollowing_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getFollowing_result()
    result.success = yield gen.Task(self._handler.getFollowing, args.key, args.part)
    oprot.writeMessageBegin("getFollowing", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()
    callback()


# HELPER FUNCTIONS AND STRUCTURES

class login_args:
  """
  Attributes:
   - principal
   - loginProperties
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'principal', None, None, ), # 1
    (2, TType.MAP, 'loginProperties', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, principal=None, loginProperties=None,):
    self.principal = principal
    self.loginProperties = loginProperties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.principal = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.loginProperties = {}
          (_ktype136, _vtype137, _size135 ) = iprot.readMapBegin()
          for _i139 in xrange(_size135):
            _key140 = iprot.readString();
            _val141 = iprot.readString();
            self.loginProperties[_key140] = _val141
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_args')
    if self.principal is not None:
      oprot.writeFieldBegin('principal', TType.STRING, 1)
      oprot.writeString(self.principal)
      oprot.writeFieldEnd()
    if self.loginProperties is not None:
      oprot.writeFieldBegin('loginProperties', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.loginProperties))
      for kiter142,viter143 in self.loginProperties.items():
        oprot.writeString(kiter142)
        oprot.writeString(viter143)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class login_result:
  """
  Attributes:
   - success
   - ouch2
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch2=None,):
    self.success = success
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 1)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addConstraint_args:
  """
  Attributes:
   - login
   - tableName
   - constraintClassName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'constraintClassName', None, None, ), # 3
  )

  def __init__(self, login=None, tableName=None, constraintClassName=None,):
    self.login = login
    self.tableName = tableName
    self.constraintClassName = constraintClassName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.constraintClassName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addConstraint_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.constraintClassName is not None:
      oprot.writeFieldBegin('constraintClassName', TType.STRING, 3)
      oprot.writeString(self.constraintClassName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addConstraint_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addConstraint_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addSplits_args:
  """
  Attributes:
   - login
   - tableName
   - splits
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.SET, 'splits', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, login=None, tableName=None, splits=None,):
    self.login = login
    self.tableName = tableName
    self.splits = splits

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.splits = set()
          (_etype147, _size144) = iprot.readSetBegin()
          for _i148 in xrange(_size144):
            _elem149 = iprot.readString();
            self.splits.add(_elem149)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addSplits_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.splits is not None:
      oprot.writeFieldBegin('splits', TType.SET, 3)
      oprot.writeSetBegin(TType.STRING, len(self.splits))
      for iter150 in self.splits:
        oprot.writeString(iter150)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addSplits_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addSplits_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class attachIterator_args:
  """
  Attributes:
   - login
   - tableName
   - setting
   - scopes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ), # 3
    (4, TType.SET, 'scopes', (TType.I32,None), None, ), # 4
  )

  def __init__(self, login=None, tableName=None, setting=None, scopes=None,):
    self.login = login
    self.tableName = tableName
    self.setting = setting
    self.scopes = scopes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.setting = IteratorSetting()
          self.setting.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.scopes = set()
          (_etype154, _size151) = iprot.readSetBegin()
          for _i155 in xrange(_size151):
            _elem156 = iprot.readI32();
            self.scopes.add(_elem156)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('attachIterator_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.setting is not None:
      oprot.writeFieldBegin('setting', TType.STRUCT, 3)
      self.setting.write(oprot)
      oprot.writeFieldEnd()
    if self.scopes is not None:
      oprot.writeFieldBegin('scopes', TType.SET, 4)
      oprot.writeSetBegin(TType.I32, len(self.scopes))
      for iter157 in self.scopes:
        oprot.writeI32(iter157)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class attachIterator_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloSecurityException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('attachIterator_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class checkIteratorConflicts_args:
  """
  Attributes:
   - login
   - tableName
   - setting
   - scopes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ), # 3
    (4, TType.SET, 'scopes', (TType.I32,None), None, ), # 4
  )

  def __init__(self, login=None, tableName=None, setting=None, scopes=None,):
    self.login = login
    self.tableName = tableName
    self.setting = setting
    self.scopes = scopes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.setting = IteratorSetting()
          self.setting.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.scopes = set()
          (_etype161, _size158) = iprot.readSetBegin()
          for _i162 in xrange(_size158):
            _elem163 = iprot.readI32();
            self.scopes.add(_elem163)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('checkIteratorConflicts_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.setting is not None:
      oprot.writeFieldBegin('setting', TType.STRUCT, 3)
      self.setting.write(oprot)
      oprot.writeFieldEnd()
    if self.scopes is not None:
      oprot.writeFieldBegin('scopes', TType.SET, 4)
      oprot.writeSetBegin(TType.I32, len(self.scopes))
      for iter164 in self.scopes:
        oprot.writeI32(iter164)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class checkIteratorConflicts_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloSecurityException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('checkIteratorConflicts_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearLocatorCache_args:
  """
  Attributes:
   - login
   - tableName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
  )

  def __init__(self, login=None, tableName=None,):
    self.login = login
    self.tableName = tableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearLocatorCache_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearLocatorCache_result:
  """
  Attributes:
   - ouch1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch1=None,):
    self.ouch1 = ouch1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = TableNotFoundException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearLocatorCache_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cloneTable_args:
  """
  Attributes:
   - login
   - tableName
   - newTableName
   - flush
   - propertiesToSet
   - propertiesToExclude
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'newTableName', None, None, ), # 3
    (4, TType.BOOL, 'flush', None, None, ), # 4
    (5, TType.MAP, 'propertiesToSet', (TType.STRING,None,TType.STRING,None), None, ), # 5
    (6, TType.SET, 'propertiesToExclude', (TType.STRING,None), None, ), # 6
  )

  def __init__(self, login=None, tableName=None, newTableName=None, flush=None, propertiesToSet=None, propertiesToExclude=None,):
    self.login = login
    self.tableName = tableName
    self.newTableName = newTableName
    self.flush = flush
    self.propertiesToSet = propertiesToSet
    self.propertiesToExclude = propertiesToExclude

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.newTableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.flush = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.propertiesToSet = {}
          (_ktype166, _vtype167, _size165 ) = iprot.readMapBegin()
          for _i169 in xrange(_size165):
            _key170 = iprot.readString();
            _val171 = iprot.readString();
            self.propertiesToSet[_key170] = _val171
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.SET:
          self.propertiesToExclude = set()
          (_etype175, _size172) = iprot.readSetBegin()
          for _i176 in xrange(_size172):
            _elem177 = iprot.readString();
            self.propertiesToExclude.add(_elem177)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cloneTable_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.newTableName is not None:
      oprot.writeFieldBegin('newTableName', TType.STRING, 3)
      oprot.writeString(self.newTableName)
      oprot.writeFieldEnd()
    if self.flush is not None:
      oprot.writeFieldBegin('flush', TType.BOOL, 4)
      oprot.writeBool(self.flush)
      oprot.writeFieldEnd()
    if self.propertiesToSet is not None:
      oprot.writeFieldBegin('propertiesToSet', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.propertiesToSet))
      for kiter178,viter179 in self.propertiesToSet.items():
        oprot.writeString(kiter178)
        oprot.writeString(viter179)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.propertiesToExclude is not None:
      oprot.writeFieldBegin('propertiesToExclude', TType.SET, 6)
      oprot.writeSetBegin(TType.STRING, len(self.propertiesToExclude))
      for iter180 in self.propertiesToExclude:
        oprot.writeString(iter180)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cloneTable_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
   - ouch4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ouch4', (TableExistsException, TableExistsException.thrift_spec), None, ), # 4
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3
    self.ouch4 = ouch4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ouch4 = TableExistsException()
          self.ouch4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cloneTable_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch4 is not None:
      oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
      self.ouch4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compactTable_args:
  """
  Attributes:
   - login
   - tableName
   - startRow
   - endRow
   - iterators
   - flush
   - wait
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'startRow', None, None, ), # 3
    (4, TType.STRING, 'endRow', None, None, ), # 4
    (5, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 5
    (6, TType.BOOL, 'flush', None, None, ), # 6
    (7, TType.BOOL, 'wait', None, None, ), # 7
  )

  def __init__(self, login=None, tableName=None, startRow=None, endRow=None, iterators=None, flush=None, wait=None,):
    self.login = login
    self.tableName = tableName
    self.startRow = startRow
    self.endRow = endRow
    self.iterators = iterators
    self.flush = flush
    self.wait = wait

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.startRow = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.endRow = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.iterators = []
          (_etype184, _size181) = iprot.readListBegin()
          for _i185 in xrange(_size181):
            _elem186 = IteratorSetting()
            _elem186.read(iprot)
            self.iterators.append(_elem186)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.flush = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.wait = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compactTable_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.startRow is not None:
      oprot.writeFieldBegin('startRow', TType.STRING, 3)
      oprot.writeString(self.startRow)
      oprot.writeFieldEnd()
    if self.endRow is not None:
      oprot.writeFieldBegin('endRow', TType.STRING, 4)
      oprot.writeString(self.endRow)
      oprot.writeFieldEnd()
    if self.iterators is not None:
      oprot.writeFieldBegin('iterators', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
      for iter187 in self.iterators:
        iter187.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.flush is not None:
      oprot.writeFieldBegin('flush', TType.BOOL, 6)
      oprot.writeBool(self.flush)
      oprot.writeFieldEnd()
    if self.wait is not None:
      oprot.writeFieldBegin('wait', TType.BOOL, 7)
      oprot.writeBool(self.wait)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compactTable_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloSecurityException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = TableNotFoundException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = AccumuloException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compactTable_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancelCompaction_args:
  """
  Attributes:
   - login
   - tableName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
  )

  def __init__(self, login=None, tableName=None,):
    self.login = login
    self.tableName = tableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancelCompaction_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancelCompaction_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloSecurityException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = TableNotFoundException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = AccumuloException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancelCompaction_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createTable_args:
  """
  Attributes:
   - login
   - tableName
   - versioningIter
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.BOOL, 'versioningIter', None, None, ), # 3
    (4, TType.I32, 'type', None, None, ), # 4
  )

  def __init__(self, login=None, tableName=None, versioningIter=None, type=None,):
    self.login = login
    self.tableName = tableName
    self.versioningIter = versioningIter
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.versioningIter = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createTable_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.versioningIter is not None:
      oprot.writeFieldBegin('versioningIter', TType.BOOL, 3)
      oprot.writeBool(self.versioningIter)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 4)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createTable_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableExistsException, TableExistsException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableExistsException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createTable_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteTable_args:
  """
  Attributes:
   - login
   - tableName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
  )

  def __init__(self, login=None, tableName=None,):
    self.login = login
    self.tableName = tableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteTable_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteTable_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteTable_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteRows_args:
  """
  Attributes:
   - login
   - tableName
   - startRow
   - endRow
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'startRow', None, None, ), # 3
    (4, TType.STRING, 'endRow', None, None, ), # 4
  )

  def __init__(self, login=None, tableName=None, startRow=None, endRow=None,):
    self.login = login
    self.tableName = tableName
    self.startRow = startRow
    self.endRow = endRow

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.startRow = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.endRow = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteRows_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.startRow is not None:
      oprot.writeFieldBegin('startRow', TType.STRING, 3)
      oprot.writeString(self.startRow)
      oprot.writeFieldEnd()
    if self.endRow is not None:
      oprot.writeFieldBegin('endRow', TType.STRING, 4)
      oprot.writeString(self.endRow)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteRows_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteRows_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exportTable_args:
  """
  Attributes:
   - login
   - tableName
   - exportDir
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'exportDir', None, None, ), # 3
  )

  def __init__(self, login=None, tableName=None, exportDir=None,):
    self.login = login
    self.tableName = tableName
    self.exportDir = exportDir

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.exportDir = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exportTable_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.exportDir is not None:
      oprot.writeFieldBegin('exportDir', TType.STRING, 3)
      oprot.writeString(self.exportDir)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exportTable_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exportTable_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class flushTable_args:
  """
  Attributes:
   - login
   - tableName
   - startRow
   - endRow
   - wait
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'startRow', None, None, ), # 3
    (4, TType.STRING, 'endRow', None, None, ), # 4
    (5, TType.BOOL, 'wait', None, None, ), # 5
  )

  def __init__(self, login=None, tableName=None, startRow=None, endRow=None, wait=None,):
    self.login = login
    self.tableName = tableName
    self.startRow = startRow
    self.endRow = endRow
    self.wait = wait

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.startRow = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.endRow = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.wait = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('flushTable_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.startRow is not None:
      oprot.writeFieldBegin('startRow', TType.STRING, 3)
      oprot.writeString(self.startRow)
      oprot.writeFieldEnd()
    if self.endRow is not None:
      oprot.writeFieldBegin('endRow', TType.STRING, 4)
      oprot.writeString(self.endRow)
      oprot.writeFieldEnd()
    if self.wait is not None:
      oprot.writeFieldBegin('wait', TType.BOOL, 5)
      oprot.writeBool(self.wait)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class flushTable_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('flushTable_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDiskUsage_args:
  """
  Attributes:
   - login
   - tables
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.SET, 'tables', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, login=None, tables=None,):
    self.login = login
    self.tables = tables

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.tables = set()
          (_etype191, _size188) = iprot.readSetBegin()
          for _i192 in xrange(_size188):
            _elem193 = iprot.readString();
            self.tables.add(_elem193)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDiskUsage_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tables is not None:
      oprot.writeFieldBegin('tables', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.tables))
      for iter194 in self.tables:
        oprot.writeString(iter194)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDiskUsage_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(DiskUsage, DiskUsage.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype198, _size195) = iprot.readListBegin()
          for _i199 in xrange(_size195):
            _elem200 = DiskUsage()
            _elem200.read(iprot)
            self.success.append(_elem200)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDiskUsage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter201 in self.success:
        iter201.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLocalityGroups_args:
  """
  Attributes:
   - login
   - tableName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
  )

  def __init__(self, login=None, tableName=None,):
    self.login = login
    self.tableName = tableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLocalityGroups_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLocalityGroups_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype203, _vtype204, _size202 ) = iprot.readMapBegin()
          for _i206 in xrange(_size202):
            _key207 = iprot.readString();
            _val208 = set()
            (_etype212, _size209) = iprot.readSetBegin()
            for _i213 in xrange(_size209):
              _elem214 = iprot.readString();
              _val208.add(_elem214)
            iprot.readSetEnd()
            self.success[_key207] = _val208
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLocalityGroups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter215,viter216 in self.success.items():
        oprot.writeString(kiter215)
        oprot.writeSetBegin(TType.STRING, len(viter216))
        for iter217 in viter216:
          oprot.writeString(iter217)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getIteratorSetting_args:
  """
  Attributes:
   - login
   - tableName
   - iteratorName
   - scope
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'iteratorName', None, None, ), # 3
    (4, TType.I32, 'scope', None, None, ), # 4
  )

  def __init__(self, login=None, tableName=None, iteratorName=None, scope=None,):
    self.login = login
    self.tableName = tableName
    self.iteratorName = iteratorName
    self.scope = scope

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.iteratorName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.scope = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getIteratorSetting_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.iteratorName is not None:
      oprot.writeFieldBegin('iteratorName', TType.STRING, 3)
      oprot.writeString(self.iteratorName)
      oprot.writeFieldEnd()
    if self.scope is not None:
      oprot.writeFieldBegin('scope', TType.I32, 4)
      oprot.writeI32(self.scope)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getIteratorSetting_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (IteratorSetting, IteratorSetting.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = IteratorSetting()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getIteratorSetting_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMaxRow_args:
  """
  Attributes:
   - login
   - tableName
   - auths
   - startRow
   - startInclusive
   - endRow
   - endInclusive
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.SET, 'auths', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'startRow', None, None, ), # 4
    (5, TType.BOOL, 'startInclusive', None, None, ), # 5
    (6, TType.STRING, 'endRow', None, None, ), # 6
    (7, TType.BOOL, 'endInclusive', None, None, ), # 7
  )

  def __init__(self, login=None, tableName=None, auths=None, startRow=None, startInclusive=None, endRow=None, endInclusive=None,):
    self.login = login
    self.tableName = tableName
    self.auths = auths
    self.startRow = startRow
    self.startInclusive = startInclusive
    self.endRow = endRow
    self.endInclusive = endInclusive

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.auths = set()
          (_etype221, _size218) = iprot.readSetBegin()
          for _i222 in xrange(_size218):
            _elem223 = iprot.readString();
            self.auths.add(_elem223)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.startRow = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.startInclusive = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.endRow = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.endInclusive = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMaxRow_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.auths is not None:
      oprot.writeFieldBegin('auths', TType.SET, 3)
      oprot.writeSetBegin(TType.STRING, len(self.auths))
      for iter224 in self.auths:
        oprot.writeString(iter224)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.startRow is not None:
      oprot.writeFieldBegin('startRow', TType.STRING, 4)
      oprot.writeString(self.startRow)
      oprot.writeFieldEnd()
    if self.startInclusive is not None:
      oprot.writeFieldBegin('startInclusive', TType.BOOL, 5)
      oprot.writeBool(self.startInclusive)
      oprot.writeFieldEnd()
    if self.endRow is not None:
      oprot.writeFieldBegin('endRow', TType.STRING, 6)
      oprot.writeString(self.endRow)
      oprot.writeFieldEnd()
    if self.endInclusive is not None:
      oprot.writeFieldBegin('endInclusive', TType.BOOL, 7)
      oprot.writeBool(self.endInclusive)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMaxRow_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMaxRow_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTableProperties_args:
  """
  Attributes:
   - login
   - tableName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
  )

  def __init__(self, login=None, tableName=None,):
    self.login = login
    self.tableName = tableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTableProperties_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTableProperties_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype226, _vtype227, _size225 ) = iprot.readMapBegin()
          for _i229 in xrange(_size225):
            _key230 = iprot.readString();
            _val231 = iprot.readString();
            self.success[_key230] = _val231
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTableProperties_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter232,viter233 in self.success.items():
        oprot.writeString(kiter232)
        oprot.writeString(viter233)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class importDirectory_args:
  """
  Attributes:
   - login
   - tableName
   - importDir
   - failureDir
   - setTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'importDir', None, None, ), # 3
    (4, TType.STRING, 'failureDir', None, None, ), # 4
    (5, TType.BOOL, 'setTime', None, None, ), # 5
  )

  def __init__(self, login=None, tableName=None, importDir=None, failureDir=None, setTime=None,):
    self.login = login
    self.tableName = tableName
    self.importDir = importDir
    self.failureDir = failureDir
    self.setTime = setTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.importDir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.failureDir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.setTime = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('importDirectory_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.importDir is not None:
      oprot.writeFieldBegin('importDir', TType.STRING, 3)
      oprot.writeString(self.importDir)
      oprot.writeFieldEnd()
    if self.failureDir is not None:
      oprot.writeFieldBegin('failureDir', TType.STRING, 4)
      oprot.writeString(self.failureDir)
      oprot.writeFieldEnd()
    if self.setTime is not None:
      oprot.writeFieldBegin('setTime', TType.BOOL, 5)
      oprot.writeBool(self.setTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class importDirectory_result:
  """
  Attributes:
   - ouch1
   - ouch3
   - ouch4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch4', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch3=None, ouch4=None,):
    self.ouch1 = ouch1
    self.ouch3 = ouch3
    self.ouch4 = ouch4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = TableNotFoundException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch3 = AccumuloException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch4 = AccumuloSecurityException()
          self.ouch4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('importDirectory_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 2)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch4 is not None:
      oprot.writeFieldBegin('ouch4', TType.STRUCT, 3)
      self.ouch4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class importTable_args:
  """
  Attributes:
   - login
   - tableName
   - importDir
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'importDir', None, None, ), # 3
  )

  def __init__(self, login=None, tableName=None, importDir=None,):
    self.login = login
    self.tableName = tableName
    self.importDir = importDir

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.importDir = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('importTable_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.importDir is not None:
      oprot.writeFieldBegin('importDir', TType.STRING, 3)
      oprot.writeString(self.importDir)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class importTable_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (TableExistsException, TableExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = TableExistsException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = AccumuloSecurityException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('importTable_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSplits_args:
  """
  Attributes:
   - login
   - tableName
   - maxSplits
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.I32, 'maxSplits', None, None, ), # 3
  )

  def __init__(self, login=None, tableName=None, maxSplits=None,):
    self.login = login
    self.tableName = tableName
    self.maxSplits = maxSplits

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxSplits = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSplits_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.maxSplits is not None:
      oprot.writeFieldBegin('maxSplits', TType.I32, 3)
      oprot.writeI32(self.maxSplits)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSplits_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype237, _size234) = iprot.readListBegin()
          for _i238 in xrange(_size234):
            _elem239 = iprot.readString();
            self.success.append(_elem239)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSplits_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter240 in self.success:
        oprot.writeString(iter240)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTables_args:
  """
  Attributes:
   - login
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
  )

  def __init__(self, login=None,):
    self.login = login

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTables_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTables_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype244, _size241) = iprot.readSetBegin()
          for _i245 in xrange(_size241):
            _elem246 = iprot.readString();
            self.success.add(_elem246)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTables_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter247 in self.success:
        oprot.writeString(iter247)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listIterators_args:
  """
  Attributes:
   - login
   - tableName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
  )

  def __init__(self, login=None, tableName=None,):
    self.login = login
    self.tableName = tableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listIterators_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listIterators_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.I32,None)), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype249, _vtype250, _size248 ) = iprot.readMapBegin()
          for _i252 in xrange(_size248):
            _key253 = iprot.readString();
            _val254 = set()
            (_etype258, _size255) = iprot.readSetBegin()
            for _i259 in xrange(_size255):
              _elem260 = iprot.readI32();
              _val254.add(_elem260)
            iprot.readSetEnd()
            self.success[_key253] = _val254
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listIterators_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter261,viter262 in self.success.items():
        oprot.writeString(kiter261)
        oprot.writeSetBegin(TType.I32, len(viter262))
        for iter263 in viter262:
          oprot.writeI32(iter263)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listConstraints_args:
  """
  Attributes:
   - login
   - tableName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
  )

  def __init__(self, login=None, tableName=None,):
    self.login = login
    self.tableName = tableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listConstraints_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listConstraints_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype265, _vtype266, _size264 ) = iprot.readMapBegin()
          for _i268 in xrange(_size264):
            _key269 = iprot.readString();
            _val270 = iprot.readI32();
            self.success[_key269] = _val270
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listConstraints_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
      for kiter271,viter272 in self.success.items():
        oprot.writeString(kiter271)
        oprot.writeI32(viter272)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mergeTablets_args:
  """
  Attributes:
   - login
   - tableName
   - startRow
   - endRow
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'startRow', None, None, ), # 3
    (4, TType.STRING, 'endRow', None, None, ), # 4
  )

  def __init__(self, login=None, tableName=None, startRow=None, endRow=None,):
    self.login = login
    self.tableName = tableName
    self.startRow = startRow
    self.endRow = endRow

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.startRow = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.endRow = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mergeTablets_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.startRow is not None:
      oprot.writeFieldBegin('startRow', TType.STRING, 3)
      oprot.writeString(self.startRow)
      oprot.writeFieldEnd()
    if self.endRow is not None:
      oprot.writeFieldBegin('endRow', TType.STRING, 4)
      oprot.writeString(self.endRow)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mergeTablets_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mergeTablets_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class offlineTable_args:
  """
  Attributes:
   - login
   - tableName
   - wait
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.BOOL, 'wait', None, False, ), # 3
  )

  def __init__(self, login=None, tableName=None, wait=thrift_spec[3][4],):
    self.login = login
    self.tableName = tableName
    self.wait = wait

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.wait = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('offlineTable_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.wait is not None:
      oprot.writeFieldBegin('wait', TType.BOOL, 3)
      oprot.writeBool(self.wait)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class offlineTable_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('offlineTable_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class onlineTable_args:
  """
  Attributes:
   - login
   - tableName
   - wait
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.BOOL, 'wait', None, False, ), # 3
  )

  def __init__(self, login=None, tableName=None, wait=thrift_spec[3][4],):
    self.login = login
    self.tableName = tableName
    self.wait = wait

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.wait = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('onlineTable_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.wait is not None:
      oprot.writeFieldBegin('wait', TType.BOOL, 3)
      oprot.writeBool(self.wait)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class onlineTable_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('onlineTable_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeConstraint_args:
  """
  Attributes:
   - login
   - tableName
   - constraint
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.I32, 'constraint', None, None, ), # 3
  )

  def __init__(self, login=None, tableName=None, constraint=None,):
    self.login = login
    self.tableName = tableName
    self.constraint = constraint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.constraint = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeConstraint_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.constraint is not None:
      oprot.writeFieldBegin('constraint', TType.I32, 3)
      oprot.writeI32(self.constraint)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeConstraint_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeConstraint_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeIterator_args:
  """
  Attributes:
   - login
   - tableName
   - iterName
   - scopes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'iterName', None, None, ), # 3
    (4, TType.SET, 'scopes', (TType.I32,None), None, ), # 4
  )

  def __init__(self, login=None, tableName=None, iterName=None, scopes=None,):
    self.login = login
    self.tableName = tableName
    self.iterName = iterName
    self.scopes = scopes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.iterName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.scopes = set()
          (_etype276, _size273) = iprot.readSetBegin()
          for _i277 in xrange(_size273):
            _elem278 = iprot.readI32();
            self.scopes.add(_elem278)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeIterator_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.iterName is not None:
      oprot.writeFieldBegin('iterName', TType.STRING, 3)
      oprot.writeString(self.iterName)
      oprot.writeFieldEnd()
    if self.scopes is not None:
      oprot.writeFieldBegin('scopes', TType.SET, 4)
      oprot.writeSetBegin(TType.I32, len(self.scopes))
      for iter279 in self.scopes:
        oprot.writeI32(iter279)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeIterator_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeIterator_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeTableProperty_args:
  """
  Attributes:
   - login
   - tableName
   - property
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'property', None, None, ), # 3
  )

  def __init__(self, login=None, tableName=None, property=None,):
    self.login = login
    self.tableName = tableName
    self.property = property

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.property = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeTableProperty_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.STRING, 3)
      oprot.writeString(self.property)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeTableProperty_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeTableProperty_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renameTable_args:
  """
  Attributes:
   - login
   - oldTableName
   - newTableName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'oldTableName', None, None, ), # 2
    (3, TType.STRING, 'newTableName', None, None, ), # 3
  )

  def __init__(self, login=None, oldTableName=None, newTableName=None,):
    self.login = login
    self.oldTableName = oldTableName
    self.newTableName = newTableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.oldTableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.newTableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renameTable_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.oldTableName is not None:
      oprot.writeFieldBegin('oldTableName', TType.STRING, 2)
      oprot.writeString(self.oldTableName)
      oprot.writeFieldEnd()
    if self.newTableName is not None:
      oprot.writeFieldBegin('newTableName', TType.STRING, 3)
      oprot.writeString(self.newTableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renameTable_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
   - ouch4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ouch4', (TableExistsException, TableExistsException.thrift_spec), None, ), # 4
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3
    self.ouch4 = ouch4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ouch4 = TableExistsException()
          self.ouch4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renameTable_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch4 is not None:
      oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
      self.ouch4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setLocalityGroups_args:
  """
  Attributes:
   - login
   - tableName
   - groups
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.MAP, 'groups', (TType.STRING,None,TType.SET,(TType.STRING,None)), None, ), # 3
  )

  def __init__(self, login=None, tableName=None, groups=None,):
    self.login = login
    self.tableName = tableName
    self.groups = groups

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.groups = {}
          (_ktype281, _vtype282, _size280 ) = iprot.readMapBegin()
          for _i284 in xrange(_size280):
            _key285 = iprot.readString();
            _val286 = set()
            (_etype290, _size287) = iprot.readSetBegin()
            for _i291 in xrange(_size287):
              _elem292 = iprot.readString();
              _val286.add(_elem292)
            iprot.readSetEnd()
            self.groups[_key285] = _val286
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setLocalityGroups_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.groups is not None:
      oprot.writeFieldBegin('groups', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.groups))
      for kiter293,viter294 in self.groups.items():
        oprot.writeString(kiter293)
        oprot.writeSetBegin(TType.STRING, len(viter294))
        for iter295 in viter294:
          oprot.writeString(iter295)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setLocalityGroups_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setLocalityGroups_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setTableProperty_args:
  """
  Attributes:
   - login
   - tableName
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'property', None, None, ), # 3
    (4, TType.STRING, 'value', None, None, ), # 4
  )

  def __init__(self, login=None, tableName=None, property=None, value=None,):
    self.login = login
    self.tableName = tableName
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.property = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setTableProperty_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.STRING, 3)
      oprot.writeString(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 4)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setTableProperty_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setTableProperty_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class splitRangeByTablets_args:
  """
  Attributes:
   - login
   - tableName
   - range
   - maxSplits
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRUCT, 'range', (Range, Range.thrift_spec), None, ), # 3
    (4, TType.I32, 'maxSplits', None, None, ), # 4
  )

  def __init__(self, login=None, tableName=None, range=None, maxSplits=None,):
    self.login = login
    self.tableName = tableName
    self.range = range
    self.maxSplits = maxSplits

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.range = Range()
          self.range.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maxSplits = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('splitRangeByTablets_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.range is not None:
      oprot.writeFieldBegin('range', TType.STRUCT, 3)
      self.range.write(oprot)
      oprot.writeFieldEnd()
    if self.maxSplits is not None:
      oprot.writeFieldBegin('maxSplits', TType.I32, 4)
      oprot.writeI32(self.maxSplits)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class splitRangeByTablets_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT,(Range, Range.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype299, _size296) = iprot.readSetBegin()
          for _i300 in xrange(_size296):
            _elem301 = Range()
            _elem301.read(iprot)
            self.success.add(_elem301)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('splitRangeByTablets_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRUCT, len(self.success))
      for iter302 in self.success:
        iter302.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tableExists_args:
  """
  Attributes:
   - login
   - tableName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
  )

  def __init__(self, login=None, tableName=None,):
    self.login = login
    self.tableName = tableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tableExists_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tableExists_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tableExists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tableIdMap_args:
  """
  Attributes:
   - login
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
  )

  def __init__(self, login=None,):
    self.login = login

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tableIdMap_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tableIdMap_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype304, _vtype305, _size303 ) = iprot.readMapBegin()
          for _i307 in xrange(_size303):
            _key308 = iprot.readString();
            _val309 = iprot.readString();
            self.success[_key308] = _val309
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tableIdMap_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter310,viter311 in self.success.items():
        oprot.writeString(kiter310)
        oprot.writeString(viter311)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testTableClassLoad_args:
  """
  Attributes:
   - login
   - tableName
   - className
   - asTypeName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'className', None, None, ), # 3
    (4, TType.STRING, 'asTypeName', None, None, ), # 4
  )

  def __init__(self, login=None, tableName=None, className=None, asTypeName=None,):
    self.login = login
    self.tableName = tableName
    self.className = className
    self.asTypeName = asTypeName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.className = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.asTypeName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testTableClassLoad_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.className is not None:
      oprot.writeFieldBegin('className', TType.STRING, 3)
      oprot.writeString(self.className)
      oprot.writeFieldEnd()
    if self.asTypeName is not None:
      oprot.writeFieldBegin('asTypeName', TType.STRING, 4)
      oprot.writeString(self.asTypeName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testTableClassLoad_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testTableClassLoad_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingTabletServer_args:
  """
  Attributes:
   - login
   - tserver
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tserver', None, None, ), # 2
  )

  def __init__(self, login=None, tserver=None,):
    self.login = login
    self.tserver = tserver

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tserver = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingTabletServer_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tserver is not None:
      oprot.writeFieldBegin('tserver', TType.STRING, 2)
      oprot.writeString(self.tserver)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingTabletServer_result:
  """
  Attributes:
   - ouch1
   - ouch2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, ouch1=None, ouch2=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingTabletServer_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getActiveScans_args:
  """
  Attributes:
   - login
   - tserver
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tserver', None, None, ), # 2
  )

  def __init__(self, login=None, tserver=None,):
    self.login = login
    self.tserver = tserver

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tserver = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getActiveScans_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tserver is not None:
      oprot.writeFieldBegin('tserver', TType.STRING, 2)
      oprot.writeString(self.tserver)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getActiveScans_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ActiveScan, ActiveScan.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ouch1=None, ouch2=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype315, _size312) = iprot.readListBegin()
          for _i316 in xrange(_size312):
            _elem317 = ActiveScan()
            _elem317.read(iprot)
            self.success.append(_elem317)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getActiveScans_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter318 in self.success:
        iter318.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getActiveCompactions_args:
  """
  Attributes:
   - login
   - tserver
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tserver', None, None, ), # 2
  )

  def __init__(self, login=None, tserver=None,):
    self.login = login
    self.tserver = tserver

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tserver = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getActiveCompactions_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tserver is not None:
      oprot.writeFieldBegin('tserver', TType.STRING, 2)
      oprot.writeString(self.tserver)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getActiveCompactions_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ActiveCompaction, ActiveCompaction.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ouch1=None, ouch2=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype322, _size319) = iprot.readListBegin()
          for _i323 in xrange(_size319):
            _elem324 = ActiveCompaction()
            _elem324.read(iprot)
            self.success.append(_elem324)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getActiveCompactions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter325 in self.success:
        iter325.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSiteConfiguration_args:
  """
  Attributes:
   - login
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
  )

  def __init__(self, login=None,):
    self.login = login

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSiteConfiguration_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSiteConfiguration_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ouch1=None, ouch2=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype327, _vtype328, _size326 ) = iprot.readMapBegin()
          for _i330 in xrange(_size326):
            _key331 = iprot.readString();
            _val332 = iprot.readString();
            self.success[_key331] = _val332
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSiteConfiguration_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter333,viter334 in self.success.items():
        oprot.writeString(kiter333)
        oprot.writeString(viter334)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSystemConfiguration_args:
  """
  Attributes:
   - login
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
  )

  def __init__(self, login=None,):
    self.login = login

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSystemConfiguration_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSystemConfiguration_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ouch1=None, ouch2=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype336, _vtype337, _size335 ) = iprot.readMapBegin()
          for _i339 in xrange(_size335):
            _key340 = iprot.readString();
            _val341 = iprot.readString();
            self.success[_key340] = _val341
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSystemConfiguration_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter342,viter343 in self.success.items():
        oprot.writeString(kiter342)
        oprot.writeString(viter343)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTabletServers_args:
  """
  Attributes:
   - login
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
  )

  def __init__(self, login=None,):
    self.login = login

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTabletServers_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTabletServers_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype347, _size344) = iprot.readListBegin()
          for _i348 in xrange(_size344):
            _elem349 = iprot.readString();
            self.success.append(_elem349)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTabletServers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter350 in self.success:
        oprot.writeString(iter350)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeProperty_args:
  """
  Attributes:
   - login
   - property
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'property', None, None, ), # 2
  )

  def __init__(self, login=None, property=None,):
    self.login = login
    self.property = property

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.property = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeProperty_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.STRING, 2)
      oprot.writeString(self.property)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeProperty_result:
  """
  Attributes:
   - ouch1
   - ouch2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, ouch1=None, ouch2=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeProperty_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setProperty_args:
  """
  Attributes:
   - login
   - property
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'property', None, None, ), # 2
    (3, TType.STRING, 'value', None, None, ), # 3
  )

  def __init__(self, login=None, property=None, value=None,):
    self.login = login
    self.property = property
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.property = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setProperty_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.STRING, 2)
      oprot.writeString(self.property)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 3)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setProperty_result:
  """
  Attributes:
   - ouch1
   - ouch2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, ouch1=None, ouch2=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setProperty_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testClassLoad_args:
  """
  Attributes:
   - login
   - className
   - asTypeName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'className', None, None, ), # 2
    (3, TType.STRING, 'asTypeName', None, None, ), # 3
  )

  def __init__(self, login=None, className=None, asTypeName=None,):
    self.login = login
    self.className = className
    self.asTypeName = asTypeName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.className = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.asTypeName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testClassLoad_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.className is not None:
      oprot.writeFieldBegin('className', TType.STRING, 2)
      oprot.writeString(self.className)
      oprot.writeFieldEnd()
    if self.asTypeName is not None:
      oprot.writeFieldBegin('asTypeName', TType.STRING, 3)
      oprot.writeString(self.asTypeName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testClassLoad_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ouch1=None, ouch2=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testClassLoad_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateUser_args:
  """
  Attributes:
   - login
   - user
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 3
  )

  def __init__(self, login=None, user=None, properties=None,):
    self.login = login
    self.user = user
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype352, _vtype353, _size351 ) = iprot.readMapBegin()
          for _i355 in xrange(_size351):
            _key356 = iprot.readString();
            _val357 = iprot.readString();
            self.properties[_key356] = _val357
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateUser_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter358,viter359 in self.properties.items():
        oprot.writeString(kiter358)
        oprot.writeString(viter359)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateUser_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ouch1=None, ouch2=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class changeUserAuthorizations_args:
  """
  Attributes:
   - login
   - user
   - authorizations
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.SET, 'authorizations', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, login=None, user=None, authorizations=None,):
    self.login = login
    self.user = user
    self.authorizations = authorizations

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.authorizations = set()
          (_etype363, _size360) = iprot.readSetBegin()
          for _i364 in xrange(_size360):
            _elem365 = iprot.readString();
            self.authorizations.add(_elem365)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('changeUserAuthorizations_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.authorizations is not None:
      oprot.writeFieldBegin('authorizations', TType.SET, 3)
      oprot.writeSetBegin(TType.STRING, len(self.authorizations))
      for iter366 in self.authorizations:
        oprot.writeString(iter366)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class changeUserAuthorizations_result:
  """
  Attributes:
   - ouch1
   - ouch2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, ouch1=None, ouch2=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('changeUserAuthorizations_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class changeLocalUserPassword_args:
  """
  Attributes:
   - login
   - user
   - password
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.STRING, 'password', None, None, ), # 3
  )

  def __init__(self, login=None, user=None, password=None,):
    self.login = login
    self.user = user
    self.password = password

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.password = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('changeLocalUserPassword_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 3)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class changeLocalUserPassword_result:
  """
  Attributes:
   - ouch1
   - ouch2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, ouch1=None, ouch2=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('changeLocalUserPassword_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createLocalUser_args:
  """
  Attributes:
   - login
   - user
   - password
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.STRING, 'password', None, None, ), # 3
  )

  def __init__(self, login=None, user=None, password=None,):
    self.login = login
    self.user = user
    self.password = password

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.password = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createLocalUser_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 3)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createLocalUser_result:
  """
  Attributes:
   - ouch1
   - ouch2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, ouch1=None, ouch2=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createLocalUser_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dropLocalUser_args:
  """
  Attributes:
   - login
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
  )

  def __init__(self, login=None, user=None,):
    self.login = login
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dropLocalUser_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class dropLocalUser_result:
  """
  Attributes:
   - ouch1
   - ouch2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, ouch1=None, ouch2=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('dropLocalUser_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserAuthorizations_args:
  """
  Attributes:
   - login
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
  )

  def __init__(self, login=None, user=None,):
    self.login = login
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserAuthorizations_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserAuthorizations_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ouch1=None, ouch2=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype370, _size367) = iprot.readListBegin()
          for _i371 in xrange(_size367):
            _elem372 = iprot.readString();
            self.success.append(_elem372)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserAuthorizations_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter373 in self.success:
        oprot.writeString(iter373)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grantSystemPermission_args:
  """
  Attributes:
   - login
   - user
   - perm
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.I32, 'perm', None, None, ), # 3
  )

  def __init__(self, login=None, user=None, perm=None,):
    self.login = login
    self.user = user
    self.perm = perm

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.perm = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grantSystemPermission_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.perm is not None:
      oprot.writeFieldBegin('perm', TType.I32, 3)
      oprot.writeI32(self.perm)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grantSystemPermission_result:
  """
  Attributes:
   - ouch1
   - ouch2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, ouch1=None, ouch2=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grantSystemPermission_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grantTablePermission_args:
  """
  Attributes:
   - login
   - user
   - table
   - perm
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.STRING, 'table', None, None, ), # 3
    (4, TType.I32, 'perm', None, None, ), # 4
  )

  def __init__(self, login=None, user=None, table=None, perm=None,):
    self.login = login
    self.user = user
    self.table = table
    self.perm = perm

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.perm = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grantTablePermission_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 3)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.perm is not None:
      oprot.writeFieldBegin('perm', TType.I32, 4)
      oprot.writeI32(self.perm)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grantTablePermission_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grantTablePermission_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hasSystemPermission_args:
  """
  Attributes:
   - login
   - user
   - perm
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.I32, 'perm', None, None, ), # 3
  )

  def __init__(self, login=None, user=None, perm=None,):
    self.login = login
    self.user = user
    self.perm = perm

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.perm = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hasSystemPermission_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.perm is not None:
      oprot.writeFieldBegin('perm', TType.I32, 3)
      oprot.writeI32(self.perm)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hasSystemPermission_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ouch1=None, ouch2=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hasSystemPermission_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hasTablePermission_args:
  """
  Attributes:
   - login
   - user
   - table
   - perm
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.STRING, 'table', None, None, ), # 3
    (4, TType.I32, 'perm', None, None, ), # 4
  )

  def __init__(self, login=None, user=None, table=None, perm=None,):
    self.login = login
    self.user = user
    self.table = table
    self.perm = perm

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.perm = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hasTablePermission_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 3)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.perm is not None:
      oprot.writeFieldBegin('perm', TType.I32, 4)
      oprot.writeI32(self.perm)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hasTablePermission_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hasTablePermission_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listLocalUsers_args:
  """
  Attributes:
   - login
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
  )

  def __init__(self, login=None,):
    self.login = login

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listLocalUsers_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listLocalUsers_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype377, _size374) = iprot.readSetBegin()
          for _i378 in xrange(_size374):
            _elem379 = iprot.readString();
            self.success.add(_elem379)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listLocalUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter380 in self.success:
        oprot.writeString(iter380)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revokeSystemPermission_args:
  """
  Attributes:
   - login
   - user
   - perm
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.I32, 'perm', None, None, ), # 3
  )

  def __init__(self, login=None, user=None, perm=None,):
    self.login = login
    self.user = user
    self.perm = perm

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.perm = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revokeSystemPermission_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.perm is not None:
      oprot.writeFieldBegin('perm', TType.I32, 3)
      oprot.writeI32(self.perm)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revokeSystemPermission_result:
  """
  Attributes:
   - ouch1
   - ouch2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
  )

  def __init__(self, ouch1=None, ouch2=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revokeSystemPermission_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revokeTablePermission_args:
  """
  Attributes:
   - login
   - user
   - table
   - perm
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.STRING, 'table', None, None, ), # 3
    (4, TType.I32, 'perm', None, None, ), # 4
  )

  def __init__(self, login=None, user=None, table=None, perm=None,):
    self.login = login
    self.user = user
    self.table = table
    self.perm = perm

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.perm = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revokeTablePermission_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 3)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.perm is not None:
      oprot.writeFieldBegin('perm', TType.I32, 4)
      oprot.writeI32(self.perm)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revokeTablePermission_result:
  """
  Attributes:
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revokeTablePermission_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createBatchScanner_args:
  """
  Attributes:
   - login
   - tableName
   - options
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRUCT, 'options', (BatchScanOptions, BatchScanOptions.thrift_spec), None, ), # 3
  )

  def __init__(self, login=None, tableName=None, options=None,):
    self.login = login
    self.tableName = tableName
    self.options = options

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.options = BatchScanOptions()
          self.options.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createBatchScanner_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.options is not None:
      oprot.writeFieldBegin('options', TType.STRUCT, 3)
      self.options.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createBatchScanner_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createBatchScanner_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createScanner_args:
  """
  Attributes:
   - login
   - tableName
   - options
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRUCT, 'options', (ScanOptions, ScanOptions.thrift_spec), None, ), # 3
  )

  def __init__(self, login=None, tableName=None, options=None,):
    self.login = login
    self.tableName = tableName
    self.options = options

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.options = ScanOptions()
          self.options.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createScanner_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.options is not None:
      oprot.writeFieldBegin('options', TType.STRUCT, 3)
      self.options.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createScanner_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createScanner_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hasNext_args:
  """
  Attributes:
   - scanner
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'scanner', None, None, ), # 1
  )

  def __init__(self, scanner=None,):
    self.scanner = scanner

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.scanner = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hasNext_args')
    if self.scanner is not None:
      oprot.writeFieldBegin('scanner', TType.STRING, 1)
      oprot.writeString(self.scanner)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hasNext_result:
  """
  Attributes:
   - success
   - ouch1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch1', (UnknownScanner, UnknownScanner.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch1=None,):
    self.success = success
    self.ouch1 = ouch1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = UnknownScanner()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hasNext_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class nextEntry_args:
  """
  Attributes:
   - scanner
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'scanner', None, None, ), # 1
  )

  def __init__(self, scanner=None,):
    self.scanner = scanner

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.scanner = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('nextEntry_args')
    if self.scanner is not None:
      oprot.writeFieldBegin('scanner', TType.STRING, 1)
      oprot.writeString(self.scanner)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class nextEntry_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (KeyValueAndPeek, KeyValueAndPeek.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (NoMoreEntriesException, NoMoreEntriesException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (UnknownScanner, UnknownScanner.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = KeyValueAndPeek()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = NoMoreEntriesException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = UnknownScanner()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = AccumuloSecurityException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('nextEntry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class nextK_args:
  """
  Attributes:
   - scanner
   - k
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'scanner', None, None, ), # 1
    (2, TType.I32, 'k', None, None, ), # 2
  )

  def __init__(self, scanner=None, k=None,):
    self.scanner = scanner
    self.k = k

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.scanner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.k = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('nextK_args')
    if self.scanner is not None:
      oprot.writeFieldBegin('scanner', TType.STRING, 1)
      oprot.writeString(self.scanner)
      oprot.writeFieldEnd()
    if self.k is not None:
      oprot.writeFieldBegin('k', TType.I32, 2)
      oprot.writeI32(self.k)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class nextK_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ScanResult, ScanResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (NoMoreEntriesException, NoMoreEntriesException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (UnknownScanner, UnknownScanner.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ScanResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = NoMoreEntriesException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = UnknownScanner()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = AccumuloSecurityException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('nextK_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeScanner_args:
  """
  Attributes:
   - scanner
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'scanner', None, None, ), # 1
  )

  def __init__(self, scanner=None,):
    self.scanner = scanner

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.scanner = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeScanner_args')
    if self.scanner is not None:
      oprot.writeFieldBegin('scanner', TType.STRING, 1)
      oprot.writeString(self.scanner)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeScanner_result:
  """
  Attributes:
   - ouch1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (UnknownScanner, UnknownScanner.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch1=None,):
    self.ouch1 = ouch1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = UnknownScanner()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeScanner_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateAndFlush_args:
  """
  Attributes:
   - login
   - tableName
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.MAP, 'cells', (TType.STRING,None,TType.LIST,(TType.STRUCT,(ColumnUpdate, ColumnUpdate.thrift_spec))), None, ), # 3
  )

  def __init__(self, login=None, tableName=None, cells=None,):
    self.login = login
    self.tableName = tableName
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.cells = {}
          (_ktype382, _vtype383, _size381 ) = iprot.readMapBegin()
          for _i385 in xrange(_size381):
            _key386 = iprot.readString();
            _val387 = []
            (_etype391, _size388) = iprot.readListBegin()
            for _i392 in xrange(_size388):
              _elem393 = ColumnUpdate()
              _elem393.read(iprot)
              _val387.append(_elem393)
            iprot.readListEnd()
            self.cells[_key386] = _val387
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateAndFlush_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.cells))
      for kiter394,viter395 in self.cells.items():
        oprot.writeString(kiter394)
        oprot.writeListBegin(TType.STRUCT, len(viter395))
        for iter396 in viter395:
          iter396.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateAndFlush_result:
  """
  Attributes:
   - outch1
   - ouch2
   - ouch3
   - ouch4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'outch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ouch4', (MutationsRejectedException, MutationsRejectedException.thrift_spec), None, ), # 4
  )

  def __init__(self, outch1=None, ouch2=None, ouch3=None, ouch4=None,):
    self.outch1 = outch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3
    self.ouch4 = ouch4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.outch1 = AccumuloException()
          self.outch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ouch4 = MutationsRejectedException()
          self.ouch4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateAndFlush_result')
    if self.outch1 is not None:
      oprot.writeFieldBegin('outch1', TType.STRUCT, 1)
      self.outch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch4 is not None:
      oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
      self.ouch4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createWriter_args:
  """
  Attributes:
   - login
   - tableName
   - opts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRUCT, 'opts', (WriterOptions, WriterOptions.thrift_spec), None, ), # 3
  )

  def __init__(self, login=None, tableName=None, opts=None,):
    self.login = login
    self.tableName = tableName
    self.opts = opts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.opts = WriterOptions()
          self.opts.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createWriter_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.opts is not None:
      oprot.writeFieldBegin('opts', TType.STRUCT, 3)
      self.opts.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createWriter_result:
  """
  Attributes:
   - success
   - outch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'outch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, outch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.outch1 = outch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.outch1 = AccumuloException()
          self.outch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createWriter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.outch1 is not None:
      oprot.writeFieldBegin('outch1', TType.STRUCT, 1)
      self.outch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_args:
  """
  Attributes:
   - writer
   - cells
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'writer', None, None, ), # 1
    (2, TType.MAP, 'cells', (TType.STRING,None,TType.LIST,(TType.STRUCT,(ColumnUpdate, ColumnUpdate.thrift_spec))), None, ), # 2
  )

  def __init__(self, writer=None, cells=None,):
    self.writer = writer
    self.cells = cells

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.writer = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.cells = {}
          (_ktype398, _vtype399, _size397 ) = iprot.readMapBegin()
          for _i401 in xrange(_size397):
            _key402 = iprot.readString();
            _val403 = []
            (_etype407, _size404) = iprot.readListBegin()
            for _i408 in xrange(_size404):
              _elem409 = ColumnUpdate()
              _elem409.read(iprot)
              _val403.append(_elem409)
            iprot.readListEnd()
            self.cells[_key402] = _val403
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_args')
    if self.writer is not None:
      oprot.writeFieldBegin('writer', TType.STRING, 1)
      oprot.writeString(self.writer)
      oprot.writeFieldEnd()
    if self.cells is not None:
      oprot.writeFieldBegin('cells', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.cells))
      for kiter410,viter411 in self.cells.items():
        oprot.writeString(kiter410)
        oprot.writeListBegin(TType.STRUCT, len(viter411))
        for iter412 in viter411:
          iter412.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class flush_args:
  """
  Attributes:
   - writer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'writer', None, None, ), # 1
  )

  def __init__(self, writer=None,):
    self.writer = writer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.writer = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('flush_args')
    if self.writer is not None:
      oprot.writeFieldBegin('writer', TType.STRING, 1)
      oprot.writeString(self.writer)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class flush_result:
  """
  Attributes:
   - ouch1
   - ouch2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (UnknownWriter, UnknownWriter.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (MutationsRejectedException, MutationsRejectedException.thrift_spec), None, ), # 2
  )

  def __init__(self, ouch1=None, ouch2=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = UnknownWriter()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = MutationsRejectedException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('flush_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeWriter_args:
  """
  Attributes:
   - writer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'writer', None, None, ), # 1
  )

  def __init__(self, writer=None,):
    self.writer = writer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.writer = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeWriter_args')
    if self.writer is not None:
      oprot.writeFieldBegin('writer', TType.STRING, 1)
      oprot.writeString(self.writer)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeWriter_result:
  """
  Attributes:
   - ouch1
   - ouch2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch1', (UnknownWriter, UnknownWriter.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (MutationsRejectedException, MutationsRejectedException.thrift_spec), None, ), # 2
  )

  def __init__(self, ouch1=None, ouch2=None,):
    self.ouch1 = ouch1
    self.ouch2 = ouch2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = UnknownWriter()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = MutationsRejectedException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeWriter_result')
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateRowConditionally_args:
  """
  Attributes:
   - login
   - tableName
   - row
   - updates
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'row', None, None, ), # 3
    (4, TType.STRUCT, 'updates', (ConditionalUpdates, ConditionalUpdates.thrift_spec), None, ), # 4
  )

  def __init__(self, login=None, tableName=None, row=None, updates=None,):
    self.login = login
    self.tableName = tableName
    self.row = row
    self.updates = updates

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.row = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.updates = ConditionalUpdates()
          self.updates.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateRowConditionally_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.STRING, 3)
      oprot.writeString(self.row)
      oprot.writeFieldEnd()
    if self.updates is not None:
      oprot.writeFieldBegin('updates', TType.STRUCT, 4)
      self.updates.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateRowConditionally_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateRowConditionally_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createConditionalWriter_args:
  """
  Attributes:
   - login
   - tableName
   - options
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'login', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRUCT, 'options', (ConditionalWriterOptions, ConditionalWriterOptions.thrift_spec), None, ), # 3
  )

  def __init__(self, login=None, tableName=None, options=None,):
    self.login = login
    self.tableName = tableName
    self.options = options

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.options = ConditionalWriterOptions()
          self.options.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createConditionalWriter_args')
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 1)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.options is not None:
      oprot.writeFieldBegin('options', TType.STRUCT, 3)
      self.options.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createConditionalWriter_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = AccumuloException()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloSecurityException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = TableNotFoundException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createConditionalWriter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateRowsConditionally_args:
  """
  Attributes:
   - conditionalWriter
   - updates
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'conditionalWriter', None, None, ), # 1
    (2, TType.MAP, 'updates', (TType.STRING,None,TType.STRUCT,(ConditionalUpdates, ConditionalUpdates.thrift_spec)), None, ), # 2
  )

  def __init__(self, conditionalWriter=None, updates=None,):
    self.conditionalWriter = conditionalWriter
    self.updates = updates

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.conditionalWriter = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.updates = {}
          (_ktype414, _vtype415, _size413 ) = iprot.readMapBegin()
          for _i417 in xrange(_size413):
            _key418 = iprot.readString();
            _val419 = ConditionalUpdates()
            _val419.read(iprot)
            self.updates[_key418] = _val419
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateRowsConditionally_args')
    if self.conditionalWriter is not None:
      oprot.writeFieldBegin('conditionalWriter', TType.STRING, 1)
      oprot.writeString(self.conditionalWriter)
      oprot.writeFieldEnd()
    if self.updates is not None:
      oprot.writeFieldBegin('updates', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.updates))
      for kiter420,viter421 in self.updates.items():
        oprot.writeString(kiter420)
        viter421.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateRowsConditionally_result:
  """
  Attributes:
   - success
   - ouch1
   - ouch2
   - ouch3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'ouch1', (UnknownWriter, UnknownWriter.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
    self.success = success
    self.ouch1 = ouch1
    self.ouch2 = ouch2
    self.ouch3 = ouch3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype423, _vtype424, _size422 ) = iprot.readMapBegin()
          for _i426 in xrange(_size422):
            _key427 = iprot.readString();
            _val428 = iprot.readI32();
            self.success[_key427] = _val428
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch1 = UnknownWriter()
          self.ouch1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ouch2 = AccumuloException()
          self.ouch2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ouch3 = AccumuloSecurityException()
          self.ouch3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateRowsConditionally_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
      for kiter429,viter430 in self.success.items():
        oprot.writeString(kiter429)
        oprot.writeI32(viter430)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ouch1 is not None:
      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
      self.ouch1.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch2 is not None:
      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
      self.ouch2.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch3 is not None:
      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
      self.ouch3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeConditionalWriter_args:
  """
  Attributes:
   - conditionalWriter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'conditionalWriter', None, None, ), # 1
  )

  def __init__(self, conditionalWriter=None,):
    self.conditionalWriter = conditionalWriter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.conditionalWriter = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeConditionalWriter_args')
    if self.conditionalWriter is not None:
      oprot.writeFieldBegin('conditionalWriter', TType.STRING, 1)
      oprot.writeString(self.conditionalWriter)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeConditionalWriter_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeConditionalWriter_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRowRange_args:
  """
  Attributes:
   - row
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'row', None, None, ), # 1
  )

  def __init__(self, row=None,):
    self.row = row

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.row = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRowRange_args')
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.STRING, 1)
      oprot.writeString(self.row)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRowRange_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Range, Range.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Range()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRowRange_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFollowing_args:
  """
  Attributes:
   - key
   - part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'key', (Key, Key.thrift_spec), None, ), # 1
    (2, TType.I32, 'part', None, None, ), # 2
  )

  def __init__(self, key=None, part=None,):
    self.key = key
    self.part = part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = Key()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFollowing_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.part is not None:
      oprot.writeFieldBegin('part', TType.I32, 2)
      oprot.writeI32(self.part)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFollowing_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Key, Key.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Key()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFollowing_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
